<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git Review Memo</title>
    <link href="/posts/60954/"/>
    <url>/posts/60954/</url>
    
    <content type="html"><![CDATA[<p>本文为<a href="https://git-scm.com/book/zh/v2">Pro Git</a>阅读笔记，整理了日常操作中涉及到的git操作。</p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol><li><p><code>git xxx -h</code> 可以查看该命令参数的简要介绍</p><ul><li><code>git help xxx</code>可以查看详细文档</li></ul></li><li><p>命令中<code>--</code>用来区分参数和文件路径(e.g. <code>git checkout -- &lt;file&gt;</code>)</p></li></ol><h2 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h2><ul><li><p><code>git commit --amend [--no-edit]</code> 将内容增加进上次的更改[保持提交信息不变]</p></li><li><p><code>git restore --staged &lt;file&gt;</code> <code>git reset HEAD &lt;file&gt;</code> 撤销文件暂存</p></li><li><p><code>git restore &lt;file&gt;</code> <code>git checkout -- &lt;file&gt;</code> 撤销文件的编辑(<strong><em>不可恢复</em></strong>)</p></li><li><p><code>git revert</code> 创建一个新的commit来撤销指定的commit</p></li><li><p>撤销合并见<a href="#撤销合并">下文</a></p></li></ul><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><blockquote><p>git内部是一个单向列表，每个节点的指针都指向前一个节点。<br>每个 branch 都是一个指针, HEAD 也是一个指针只想当前 checkout 出来的位置<br>这非常重要! 理解这一点就能理解下面的一切了</p></blockquote><ul><li><p>use <code>git switch</code> to switch</p></li><li><p><code>git branch [--merged | --no-merged] [&lt;name&gt;]</code> 显示已经合并(或没有合并)进当前分支(或name分支)的分支</p></li><li><code>git branch &lt;name&gt; [&lt;hash&gt;]</code> 从当前状态[使用指定hash]创建分支</li><li><p><code>git branch -d &lt;name&gt;</code> 删除指定分支(-D强制删除)</p></li><li><p><code>git checkout -b &lt;name&gt; [&lt;hash&gt;]</code> 创建并切换分支</p></li></ul><h3 id="关于合并分支与分叉"><a href="#关于合并分支与分叉" class="headerlink" title="关于合并分支与分叉"></a>关于合并分支与分叉</h3><ol><li>当两个分支都进行了各自的更改并commit后才会有所谓分叉现象，会使用 <em>3-way merge策略</em> 进行合并</li><li>如果只是一个分支有更改而另一个分支没有，则合并使用简单的 <em>fast-forward</em> 策略合并即可</li></ol><p><strong>fast-forward</strong> 当试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么Git只会简单的将指针向前推进（指针右移）</p><h3 id="遇到冲突的情况"><a href="#遇到冲突的情况" class="headerlink" title="遇到冲突的情况"></a>遇到冲突的情况</h3><ol><li><code>======</code>符号的上半部分为<code>HEAD</code>所指的文件状态，也就是当前检出的分支的文件状态，下半部分为传入的更改</li><li>在处理好冲突后，使用<code>git add</code>将其标记为处理完成</li><li><code>git mergetool</code>可以启动图形化界面帮助处理更改</li><li>全部处理完成后使用<code>git commit</code>来进行提交</li></ol><h3 id="Merge-rebase-and-squaze"><a href="#Merge-rebase-and-squaze" class="headerlink" title="Merge, rebase and squaze"></a>Merge, rebase and squaze</h3><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>merge会将待合并分支的信息全部带入到合并结果中。</p><p>问题：如果一个节点有两个前向节点怎么存储？</p><h3 id="remote-branch"><a href="#remote-branch" class="headerlink" title="remote-branch"></a>remote-branch</h3><ol><li><code>git fetch</code> 可以将服务器的数据拉取到本地来，但是并不修改本地的分支</li><li><code>git branch -vv</code> 可以查看分支追踪情况</li><li><p><code>git ls-remote</code> 显示远程情况</p></li><li><p><code>git checkout -b &lt;name&gt; &lt;remote/name&gt;</code>可以从一个远程分支创建本地分支来开始工作，这会自动创建所谓追踪分支</p></li><li><p><code>git push --set-upstream-to &lt;local_bantch_name&gt;[:&lt;remote_bantch_name&gt;]</code>可以将本地存在而远程不存在的分支推送到远程去，同样自动追踪</p><ul><li>这等价于下面两步操作</li><li>step1 <code>git push &lt;origin&gt; &lt;local_bantch_name&gt;[:&lt;remote_bantch_name&gt;]</code> 将本地的某个分支推送到远程</li><li>step2 <code>git branch [-u | --set-upstream-to] &lt;origin/xxx&gt;</code>将本地的追踪分支设定为远程的xxx</li></ul></li><li><p><code>git push origin --delete xxx</code>可以删除远程分支xxx</p><ul><li><code>git push origin :&lt;NAME&gt;</code> 效果同样</li></ul></li></ol><h4 id="关于追踪分支"><a href="#关于追踪分支" class="headerlink" title="关于追踪分支"></a>关于追踪分支</h4><ol><li><code>git checkout --track origin/serverfix</code> 也可以从远程创建追踪分支</li><li><code>git checkout serverfix</code>当本地不存在远程存在时，这样子会自动按照上一条执行</li><li><code>git checkout -b &lt;name&gt; &lt;remote/name&gt;</code> 可以创建和远程名称不同的本地分支</li></ol><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><p>Rebase 是把相对于共同祖先节点的操作整理出来依次应用到目标分支，以此来达到消除分叉的目的。</p><p>Rebase后只是checkout到目标分支进行<code>fast-forward merge</code></p><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-1.png"><br><img src="https://git-scm.com/book/en/v2/images/basic-rebase-3.png"></p><ol><li><p><code>git rebase &lt;target_branch&gt;</code>把当前分支应用到 target_branch 上</p></li><li><p><code>git rebase --onto master server client</code> 将在<code>client</code>分支里但不在<code>server</code>分支里的修改后合并到<code>master</code>上</p></li><li><p><code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 把topic整合到base上</p></li></ol><p><em>技巧</em> 如果本地和远程都有修改可以直接<code>rebase</code>本地到<code>remotes/origin/HEAD</code></p><h2 id="选择或指定commit"><a href="#选择或指定commit" class="headerlink" title="选择或指定commit"></a>选择或指定commit</h2><ol><li><p><code>git show &lt;hash&gt;</code> 用来查看指定提交</p></li><li><p><code>HEAD@&#123;n&#125;</code> HEAD第n次移动前的位置(当前为0)</p><ul><li><code>git reflog</code>可以查看历史记录</li><li>同理<code>main@&#123;3&#125;</code>可以查看main3次移动前的位置</li><li>引用日志只保存在本地</li></ul></li><li><p><code>HEAD^[n]</code> 代表HEAD的第n个父提交(不写n代表1) 用于选择在合并分叉的时候造成的多个父亲</p></li><li><p><code>HEAD~[n]</code> 节点[的父亲]*n 用来选择祖父节点</p></li><li><p><code>git log master..topic</code> topic分支中有但是master分支中没有的提交</p><ul><li><code>git diff master..topic</code> 查看两个分支的差别</li></ul></li><li><code>git log refA refB ^refC</code> refA和refB中有但是refC中没有的提交</li><li><code>git log [--left-right] master...experiment</code> 被两者之一包含但是不被同时包含的提交[显示究竟被哪个包含]</li></ol><h2 id="交互式操作"><a href="#交互式操作" class="headerlink" title="交互式操作"></a>交互式操作</h2><ol><li><code>git add -i</code> 进入交互式暂存模式，可以把文件的一部分更改add进去</li></ol><p>类似的还有下面几个(-p —patch)：</p><ol><li><code>git add -p</code></li><li><code>git stash -p</code></li><li><code>git restore -S -p</code> 交互式取消stage</li><li><code>git restore [-s] -p</code> 交互式discard(取消更改)</li></ol><h2 id="修改提交历史"><a href="#修改提交历史" class="headerlink" title="修改提交历史"></a>修改提交历史</h2><ol><li><code>git rebase -i HEAD~3</code> 交互式的rebase即可完成修改 <strong>这个操作可以对历史进行各种修改(合并、删除等等)</strong></li></ol><h2 id="关于reset和checkout"><a href="#关于reset和checkout" class="headerlink" title="关于reset和checkout"></a>关于reset和checkout</h2><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86">文档链接</a></p><p><img src="https://git-scm.com/book/en/v2/images/reset-workflow.png"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p>文档中所说的<code>Index</code>是指暂存区(看图理解)</p><ul><li>Git将上一次检出到工作目录中的所有文件填充到索引区</li><li>之后你会修改并使用<code>git add</code>将其中一些文件替换为新版本</li><li>接着通过 git commit 将它们转换为树来用作新的提交</li></ul></li><li><p><code>Working Tree</code>就是指工作目录</p></li></ol><h3 id="reset和checkout的区别"><a href="#reset和checkout的区别" class="headerlink" title="reset和checkout的区别"></a>reset和checkout的区别</h3><p><code>git checkout</code>是在移动<em>HEAD自己</em>，而<code>reset</code>是移动<em>HEAD所指向分支</em>的指向</p><h3 id="两者的使用"><a href="#两者的使用" class="headerlink" title="两者的使用"></a>两者的使用</h3><ol><li><p>commit级别</p><ul><li><code>--soft</code> 只改变<code>HEAD</code>，不改变<code>Index</code>和<code>Working Tree</code>。本质上是撤销<code>git commit</code>。这样进行<code>commit</code>相当于在进行<code>git commit -amend</code></li><li><code>--mixed</code> 改变<code>HEAD</code>和<code>Index</code>，不改变<code>Working Tree</code>。相当于在上面的基础上再进行<code>git restore -S</code></li><li><code>--hard</code> 全都改变。相当于在上谜案的基础上再进行<code>git restore -s</code>(<strong>危险</strong>)</li></ul></li><li><p>操作单个文件</p><ul><li><code>git reset [commit] &lt;paths&gt;</code> 使某个文件在<code>Index</code>中的状态变到指定版本</li><li><code>git checkout [commit] &lt;paths&gt;</code>使某个文件在<code>Working Tree</code>中的状态变到指定版本(<strong>危险</strong>)</li></ul></li></ol><h3 id="撤销合并"><a href="#撤销合并" class="headerlink" title="撤销合并"></a>撤销合并</h3><ol><li><p><code>git reset --hard HEAD~</code> 但是这会修改历史，如果已经发布更改最好不这样做</p></li><li><p><code>git revert -m 1 HEAD</code> -m指出回到哪个父节点，对于合并来说1就是刚刚合并来的那个节点</p></li></ol><h3 id="不甚严谨的几点理解"><a href="#不甚严谨的几点理解" class="headerlink" title="不甚严谨的几点理解"></a>不甚严谨的几点理解</h3><p>git主要包括节点和指针，数据和文件目录会以节点的形式存储起来，而<code>branch</code>, <code>HEAD</code>等均为指向节点的指针。</p><ul><li><code>commit</code>和<code>add</code>操作是在创建节点，其他操作几乎都是在移动指针</li><li><code>git push</code>是在移动仓库的指针<code>remotes/origin/HEAD</code>等等</li><li><code>git pull</code>是在依据设定的”追踪分支”尝试merge远程更改并移动<code>HEAD</code>指针及分支指针</li><li><code>git fetch</code>的时候会把远程仓库的数据都拿下来但是并不更改本地的指针指向，手动进行<code>merge remotes/origin/HEAD</code>操作后就相当于执行了<code>git pull</code></li><li><code>git merge rebase等</code>是在比对文件并移动<code>HEAD</code>和HEAD所指向的branch的指针</li><li><code>reset</code>是在试图直接操作指针和Index区域，</li><li>在各种指针移动的时候对应的节点并不会被删除，只是因为链接为单向的，可能因为指针的移动变得无法找到，但是只要能找到那个节点hash就可以恢复(e.g. 使用<code>reflog</code>)。换句话说，理论上只要git已经为文件创建了blob文件，那么内容就不会丢失只是可能不容易找到。</li></ul><p><strong>参考资料:</strong></p><p>全文内容为<a href="https://git-scm.com/book/zh/v2">Pro Git</a>阅读笔记</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建Apple设备描述文件并签名</title>
    <link href="/posts/6894/"/>
    <url>/posts/6894/</url>
    
    <content type="html"><![CDATA[<p>Apple开发者上大会宣布可以在macOS11.0和iOS14以上的设备上设置DoH和DoT，但是只支持用设备描述文件的方式来进行配置，这两天好奇了一下，这篇文章记录一下关于设备描述文件的资料以及给配置文件的签名的方法。</p><h2 id="创建设备描述文件"><a href="#创建设备描述文件" class="headerlink" title="创建设备描述文件"></a>创建设备描述文件</h2><p>所谓设备描述文件就是一个<code>xml</code>格式的文档，里面记录了各个配置项的值，具体内容参照下面的官方文档即可。</p><ul><li>概括性说明 <a href="https://developer.apple.com/documentation/devicemanagement/configuring_multiple_devices_using_profiles">Apple Developer Document: Configuring Multiple Devices Using Profiles</a></li><li>具体配置项文档 <a href="https://developer.apple.com/documentation/devicemanagement/profile-specific_payload_keys">Profile-Specific Payload Keys</a></li></ul><p>文件所需的<code>Payload UUID</code>可以使用<code>uuidgen</code>生成，相同id的描述文件重复安装会覆盖。</p><h2 id="描述文件的签名"><a href="#描述文件的签名" class="headerlink" title="描述文件的签名"></a>描述文件的签名</h2><p>将上一步骤的文件存储为<code>.mobileconfig</code>拓展名的文件就可以直接在设备上打开安装了，只不过这时候描述文件会显示为<code>未验证</code>或者<code>不受信任</code>，这让强迫症很难受，同时也没法确保文件在传输过程中不被篡改，所以我们要给文件加上电子签名。</p><p>首先要说明，这里苹果并不在意证书的用途，只验证证书信任链，所以对于我们没有注册成为开发者的人来说，可以用两种方法建立信任：一是使用<code>Let&#39;s Encrypt</code>等签发的域名证书，因为其根证书收到苹果信任，用这种方式签名的证书也会受到信任；二是建立自己的自签名根证书并导入设备，之后直接使用根证书签名或者使用根证书再签发证书建立自己的信任链。</p><p>考虑到<code>Let&#39;s Encrypt</code>的签发的证书有效期只有3个月，同时描述文件主要是用来给自己用或者是给组织内部使用，所以主要介绍使用自签名的方式建立信任，把借助SSL证书建立信任的方式放在最后。</p><p>这里还要说下，如果已经是苹果的开发者了，拥有苹果签发的开发者证书的话可以直接跳到最后<a href="#碎碎念">“碎碎念”</a>部分</p><h3 id="使用自签名证书"><a href="#使用自签名证书" class="headerlink" title="使用自签名证书"></a>使用自签名证书</h3><p>这里我们按照三级结构<code>Root CA --&gt; Intermediate CA --&gt; Leaf CA</code>的方式来建立。</p><p>整个步骤使用macOS自带的”钥匙串访问”和App Store下载的”Apple Configurator 2”即可轻松完成，当然也可以选用<code>openssl</code>来创建。</p><ol><li>首先在钥匙串中使用证书助理创建证书颁发机构选择创建根证书，然后再次创建证书颁发机构，这次选择创建中间证书并且选择使用刚刚创建的根证书签名，最后点击创建证书使用中级证书签名，创建叶子证书。</li><li>将自己的根证书标记为受信任，并导出，导出类型选择<code>.cer</code>即可。</li><li>完成后将描述文件用”Apple Configurator 2”打开，选择”文件-&gt;签名”，选择上一步创建的叶子证书签名。</li><li>将步骤2导出的根证书在设备上打开，会自动创建包含证书的描述文件，选择安装就会将自己的根证书加入到受信任证书列表中了。</li><li>将签名后的描述文件发送给设备，在设备上打开，这时因为根证书收到信任，所以中间证书收到信任，所以叶子证书收到信任，如果签名校验没有错误的话就会显示描述文件受到信任了。</li></ol><p><img src="https://myblog-1254913510.file.myqcloud.com/pic/keychain.png" alt="keychain" style="zoom:67%;" /></p><p>完成上面几个步骤后，对于个人来说我们可以把签名过的描述文件放到网上存储，用自己需要使用的设备访问下载，只要下载后的文件验证通过，就可以证明文件的确是自己的没有被篡改。对于组织来说可以把组织自己的Root CA预先配置在设备里面，只要描述文件签名验证通过就可以证明该文件确实为组织管理员所发布并且没有被篡改。</p><h3 id="使用SSL证书进行签名"><a href="#使用SSL证书进行签名" class="headerlink" title="使用SSL证书进行签名"></a>使用<code>SSL</code>证书进行签名</h3><p>这里因为域名证书的用途里面不包含代码签名，所以就算导入到钥匙串中，证书也不会出现在上述工具的可用证书列表里，所以我们只能使用<code>openssl</code>来完成。</p><p>以<code>Let&#39;s Encrypt</code>签发的证书为例，我们会得到<code>fullchain.pem</code>和<code>privkey.pem</code>两个文件，将他们<code>scp</code>到本地:</p><ul><li><code>fullchain.pem</code>包含了发给我们域名的叶子证书以及用于建立信任链的中级证书</li><li><code>privkey.pem</code>则是我们证书的私钥，特别注意这里的私钥是没有密码保护的，要特别注意安全</li></ul><p>主要步骤:</p><ol><li>把<code>fullchain.pem</code>中的叶子证书和中间证书分开保存，前面的部分为叶子证书(server.crt)，后面的为中间证书(ca.crt)</li><li>签名<br><code>openssl smime -sign -in unsigned.mobileconfig -out signed.mobileconfig -signer server.crt -inkey server.key  -certfile ca.crt -outform der -nodetach</code></li></ol><p>完成后就可以将描述文件发布到网上供人下载了，因为<code>Let&#39;s Encrypt</code>的根证书本身是受到设备系统信任的，就不需要再导入根证书了。</p><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>在苹果提供”Apple Configurator 2”工具之前，网上针对个人开发者证书的方法是：首先把个人开发者证书导出(.p12)，然后用<code>openssl</code>拆分成证书和私钥，因为格式不对还要转换格式(cer-&gt;crt)，然后再把Apple的中级证书下载下来合并到里面构建信任链最后再签名。</p><p>这个流程很繁琐，而且过程中先是把钥匙串中的私钥导出来，又把有密码保护的私钥直接暴露了出来，增加了安全风险，现在已经没有必要，对于有开发者证书的人来说直接按照<a href="#使用自签名证书">“使用自签名证书”</a>的步骤3选择自己的证书签名然后分发就可以了，节省时间同时也增加安全性。</p><h2 id="关于如何把证书私钥导入到钥匙串"><a href="#关于如何把证书私钥导入到钥匙串" class="headerlink" title="关于如何把证书私钥导入到钥匙串"></a>关于如何把证书私钥导入到钥匙串</h2><p>这几天仔细研究了一下钥匙串，感觉把私钥放到钥匙串保存应该比我自己靠谱不少。但是发现直接双击<code>.pem</code>格式的私钥会提示<code>项目已损坏无法取回</code>导入失败，试验来看似乎只接受<code>.p12</code>格式:</p><ol><li>将证书和私钥匙放在一起，对于<code>Let&#39;s Encrypt</code>签发的来说把<code>server.key</code>粘贴到<code>fullchain.pem</code>后面就可以了<br><code>cat server.key &gt;&gt; fullchain.pem</code></li><li>使用openssl转换格式<code>openssl pkcs12 -export -in  fullchain.pem -out cer.p12</code></li></ol><p><strong>参考资料</strong></p><ol><li><a href="https://www.jianshu.com/p/277f4c7fe2a8">Mobileconfig SSL签名</a></li><li><a href="http://www.rootmanager.com/iphone-ota-configuration/iphone-ota-setup-with-signed-mobileconfig.html">Over-the-air IPhone Setup Using a Signed .mobileconfig File</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Apple</tag>
      
      <tag>mobileconfig</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark Wi-Fi抓包</title>
    <link href="/posts/55555/"/>
    <url>/posts/55555/</url>
    
    <content type="html"><![CDATA[<p>最近这两天有点儿偏离主线了，稍微摆弄了一下之前去年这时候没弄懂咋用的<code>WireShark</code>，然后发现网上关于无线网络抓包的东西东一块西一块的，缺乏系统性整理，而且有些说法是错误的，所以写下这一篇粗浅的文章做一个简单整理和记录。</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>因为操作系统和网卡驱动可能会影响，所以贴一下实验环境：</p><p>电脑: MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports)<br>系统: MacOS 10.15.7 (19H15)</p><h2 id="抓包条件"><a href="#抓包条件" class="headerlink" title="抓包条件"></a>抓包条件</h2><p>在开始前先弄清<code>Wireshark</code>的两个模式选项:</p><blockquote><p><strong>Promiscuous mode</strong><br>In promiscuous mode the MAC address filter mentioned above is disabled and all packets of the currently joined 802.11 network (with a specific SSID and channel) are captured, just as in traditional Ethernet. However, on a “protected” network, packets from or to other hosts will not be able to be decrypted by the adapter, and will not be captured, so that promiscuous mode works the same as non-promiscuous mode.</p><p>This seems to work on Linux and various BSDs, including Mac OS X. On Windows, putting 802.11 adapters into promiscuous mode is usually crippled, see the Windows section below.</p><p><strong>Monitor mode</strong></p><p>In monitor mode the SSID filter mentioned above is disabled and <em>all</em> packets of <em>all</em> SSID’s from the currently selected channel are captured.</p><p>Even in <a href="https://wiki.wireshark.org/CaptureSetup/WLAN#promiscuous">promiscuous mode</a>, an 802.11 adapter will only supply to the host packets of the SSID the adapter has joined, assuming promiscuous mode works at all; even if it “works”, it might only supply to the host the same packets that would be seen in non-promiscuous mode. Although it can receive, at the radio level, packets on other SSID’s, it will not forward them to the host.</p><p>Therefore, in order to capture all traffic that the adapter can receive, the adapter must be put into “monitor mode”, sometimes called “rfmon mode”. In this mode, the driver will put the adapter in a mode where it will supply to the host packets from <em>all</em> service sets. Depending on the adapter and the driver, this might disassociate the adapter from the SSID, so that the machine will not be able to use that adapter for network traffic, or it might leave the adapter associated, so that it can still be used for network traffic.</p><p>——<a href="https://wiki.wireshark.org/CaptureSetup/WLAN">WLAN (IEEE 802.11) capture setup</a></p></blockquote><ul><li>混杂模式(Promiscuous)：让网卡把所有的包不管mac地址是不是发给自己的全都收进来</li><li>监视模式(Monitor Mode)：保留802.11原始头部，并且收指定信道（频率范围）能听到的所有信号，不管SSID是什么全都收进来</li></ul><p>在我的设备上测试结果是混杂模式不起作用，MacOS只给两个选择要么就开<code>Monitor Mode</code>全都收进来，要么就只收自己的，所以就分两种情况讨论下：</p><p>先说抓自己本机的，这个很容易不需要特殊配置，只要打开<code>Wireshark</code>选中自己的Wi-Fi网卡开始抓包就可以了，就算是加密的Wi-Fi出来的内容也已经是解密好的。</p><p>再说抓别人的，上面说过在我的测试环境下”混杂模式”没有起到预期的作用，所以就直接勾选无线网卡的”监视模式”，勾选后<code>Link-layer Header</code>就会变成<code>802.11 plus radiotap header</code>了。然后开启抓包，这时如果你处在像宿舍这样的周围无线信号很嘈杂的环境的话就能一下子看到非常多的报文了。</p><h3 id="选择指定的SSID"><a href="#选择指定的SSID" class="headerlink" title="选择指定的SSID"></a>选择指定的SSID</h3><p>选择<code>Wireless-&gt;WLAN Traffic</code>就可以打开<code>Wireshark</code>中的一个简单的无线网络分析工具，可以查看到Wireshark帮我们解析并统计出来的周围路由器以及和他们通信的设备，里面也包含了简要的通信量统计等信息。找到我们想要的路由器的<code>SSID</code>然后直接<code>Apply as Filter</code>就可以筛选出和这个路由器通信的包了。</p><p>如果你选择是一个没有密码的Wi-Fi，这时候就可以直接看到更上层的数据链路层报文了，如果恰好又有人在应用层使用HTTP通信的话那就可以直接看到内容，如果又恰好通信的内容也没有加密措施的话那就什么都能看到了。不过现在网站基本全都HTTPS了，应该基本是不存在这种情况了。</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>如果是加密的Wi-Fi的话那对于使用WPA2个人级别加密的Wi-Fi的话，解密负载内容需要两个条件</p><ul><li>在<code>Preferences-&gt;Protocols-&gt;IEEE 802.11</code>中勾选<code>Enable Decryption</code>并且填上Wi-Fi的密码(格式：passwd:SSID)</li><li>抓取到设备连接时和路由器完整的四次握手，开始抓包后把手边的设备Wi-Fi断开然后重新连接下即可</li></ul><p>满足这两个条件之后就可以和没有密码的Wi-Fi一样看到更上层的传输内容了。</p><p>WPA2企业级有看到说法似乎是不大行，不过这点没有求证，存疑。</p><h2 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h2><ul><li>Wireshark的抓包结果和<code>tcpdump -I</code>下的结果一致</li><li>另外macOS在无限诊断工具中已经提供了抓包工具，按住<code>option</code>点Wi-Fi图标之后在窗口那里选择就好了，可以使用Wireshark分析抓取结果</li></ul><p>最后记录一下我对一些说法的异议</p><p>第一个，对于无线网络来说，你选择了信道也就是频率范围，那么该频率下的所有包不管是发给你的还是不是发给你的，也不管是谁发出来的你都可以收到，只是你能不能解密出内容的区别。所以并不会因为Wi-Fi路由器给出来的AP隔离之类的选项导致不能抓到包。这和有线连接交换机的设置是不一样的，不需要端口镜像，更不用arp欺骗。</p><p>第二个，暂时忘了…想起来了再补…</p><p><strong>有帮助的参考资料</strong></p><ol><li><a href="https://wiki.wireshark.org/CaptureSetup/WLAN">Wireshark文档: WLAN (IEEE 802.11) capture setup</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
      <tag>WireShark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈SSL和GPG</title>
    <link href="/posts/23547/"/>
    <url>/posts/23547/</url>
    
    <content type="html"><![CDATA[<p>去年的这个时候因为想用GPG签名git提交学习了一下GPG的工作原理，还写了一篇博客简单记录。今年又是这个时候偶然看到了CloudFlare Blog 的一篇2015年的文章<a href="https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/">How to build your own public key infrastructure</a>在讲如何构建自己的自签名SSL证书用于加密后端服务内部的相互通信，文章讲的炒鸡简洁清晰，感觉一下子对之前一直迷迷糊糊的SSL证书签署过程有了比较清晰的理解，和GPG密钥两相对照之下也加深了对GPG的理解，所以写下此文简要记录一下。</p><h2 id="GPG和SSL的区别"><a href="#GPG和SSL的区别" class="headerlink" title="GPG和SSL的区别"></a>GPG和SSL的区别</h2><blockquote><p>Public key cryptography provides many mechanisms for trust, including PGP’s “web of trust” and HTTPS’s public key infrastructure (PKI) model. </p><p>——CloudFlare Blog</p></blockquote><p>这两个背后对应的是两种不同的信任机制模型，一句话来说GPG的背后PGP模型是”信任你信任的人所信任的人”，而HTTPS背后的PKI模型则是”信任权威机构信任的人”。</p><p>这两种方式都可以简单可靠的建立直接信任，所谓直接信任是指使用者因为知道一把密钥从哪里来而信任它是有效的。简单的例子比如你和我当面交换公钥，然后之后我们在网络上使用自己私钥对内容进行签名，那么我们互相都可以证明对方收到的信息真的是由自己发出的并且没有被篡改。再比如软件仓库的维护者将公钥发布在使用了HTTPS的网站上，当我们下载了软件后就可以通过验证签名确认软件没有被篡改。</p><p>但是我们在生活中往往遇到的都是需要向完全陌生人证明自己是自己这样的情况，在这种情况下两者各有优缺点：</p><p>PGP把信任机制的建立诉诸于社交网络式的结构而不是权威机构，带来的直观好处就是省下了权威机构认证的钱。坏处就是信任机制较弱，PGP可以帮助轻松的证明秘文没有被修改也可帮你完成信息的加密和解密，但是很难帮你向陌生人证明你(uid)就是你，虽然可以通过密钥被接收者也信任的人签名过来间接确认，但是信任机制的建立需要长时间慢慢积累来建立。</p><blockquote><p>随着时间过去，你累积到许多人的密钥，其中有些人你也许愿意签署信赖他们，别人也会签署一些他们自己信赖的他人密钥。每个人都逐渐累积到一些他人已签署信赖的密钥，然后自己再签署并散发出去。那么便能期待，下一个拿到这把密钥的人在签署名单上总有一两个是自己信赖的。这最终能形成所有公钥的分布式防弊的信赖网络。</p><p>——PGP的发明者 菲利普·齐默曼</p></blockquote><p>和PGP相反，PKI模型则是把信任的建立诉诸权威机构，通过权威机构逐级签署密钥的方式来建立信任，HTTPS正是采用这种方式。这样建立信任比较简单，只要将几个知名CA的证书在操作系统中就预先标记为受信任，那么由他们的私钥直接签署的证书或者由他们签署的中间级证书对应的私钥签署的证书都可以被标记为受到信任，这样的签署机制逐层传递下去就可以很轻松的使得证书的拥有者证明自己就是自己。但是正是因为信任的建立和身份的真实性的鉴别都依赖权威机构，所以证书的申请者需要为此付费，这也导致HTTPS最初推广进展缓慢，直到Let’s Encrypt 之类的免费证书签发机构的出现才改善了状况。</p><h2 id="SSL证书是如何被签署的？"><a href="#SSL证书是如何被签署的？" class="headerlink" title="SSL证书是如何被签署的？"></a>SSL证书是如何被签署的？</h2><p>要想清楚了解SSL证书的签署过程，首先要先搞清楚过程中需要的几个文件：</p><ul><li>证书：所谓证书就是一个包含拥有者信息、公钥、CA签名的一个文件</li><li>私钥：每个证书都对应一个私钥可以用来签名或者加密</li><li>CSR(certificate signing request)：包含CA签名证书所需信息的文件，我们需要把这个提交给CA来签名我们的证书，主要包括几部分<ul><li>申请者的信息</li><li>待签名证书的公钥</li><li>用自己的私钥产生的签名</li></ul></li></ul><p>在得到CSR后CA就可以开始签署过程：</p><ol><li>首先使用公钥验证CSR的签名，确保请求没有被篡改</li><li>按照审核规则检查申请者的信息，审核信息是否真实并判断是不是可以通过(典型的手段包括验证DNS记录和HTTP验证等方式)</li><li>使用CA自己的私钥创建并签名证书，并把证书发回申请者，整个过程结束</li></ol><p>需要注意的是因为对于CA来说被预先内置在操作系统中分发的证书(根证书)极为重要，相应的私钥一旦丢失就意味着信任机制的完全破坏几乎无法恢复，所以在操作中并不使用”根证书”的私钥签署，而是先用其签署一份”中级证书”之后就离线保存起来，之后使用Intermediate 证书来进行签署，这样万一真的发生泄漏只要将中级证书吊销，根证书的信任仍然可以不受破坏。</p><p>此外对于Let’s Encrypt 这样的较新的颁发机构来说，为了确保自己的证书可以被更多的浏览器信任，会使用多个已被广受信任的根证书来进行交叉签名。关于这一点的详细的描述见 <a href="https://letsencrypt.org/certificates/">Let’s Encrypt: Chain of Trust</a>。</p><h2 id="CA是如何建立的？"><a href="#CA是如何建立的？" class="headerlink" title="CA是如何建立的？"></a>CA是如何建立的？</h2><p>建立CA并不难，主要包括三步：</p><ol><li>创建根证书</li><li>创建中间证书并使用根证书签名，完成后将根证书离线安全保存</li><li>按照一定规则审核申请并使用中间证书签发证书</li></ol><p>但是要想让自己的证书广受信任就得把自己的根证书在操作系统中标记为信任，在不打扰用户的情况下这对我们来说是不可能完成的任务，所以使用自签发证书让用户的浏览器自动显示小绿锁是没有办法做到的。但是像文章开头说的那样建立自己的CA用于加密后端服务内部的相互通信是简单可行的，参照<a href="https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/">How to build your own public key infrastructure</a>就可以了。</p><h2 id="GnuPG使用备忘"><a href="#GnuPG使用备忘" class="headerlink" title="GnuPG使用备忘"></a>GnuPG使用备忘</h2><pre><code class="hljs bash">-s, --sign                  生成一份签名    --clear-sign            生成一份明文签名-b, --detach-sign           生成一份分离的签名-e, --encrypt               加密数据-d, --decrypt               解密数据（默认）    --verify                验证签名</code></pre><p>其它使用见之前的文章<a href="https://blog.yrpang.com/posts/37452/">浅谈GPG</a></p><p><strong>工具网站：</strong></p><ol><li><a href="https://crt.sh/">crt.sh</a>  用来查询证书状态</li><li><a href="https://certbot.eff.org/">certbot</a> 用来申请证书的客户端工具</li></ol><p><strong>参考资料：</strong></p><ol><li><a href="https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/">How to build your own public key infrastructure</a></li><li><a href="https://zhuanlan.zhihu.com/p/34439412">信任网络，PGP，GPG</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPG</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>proc文件系统</title>
    <link href="/posts/52529/"/>
    <url>/posts/52529/</url>
    
    <content type="html"><![CDATA[<p>记录一些确定Linux系统状态定位问题的的指令。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><blockquote><p>The  proc filesystem is a pseudo-filesystem which provides an interface<br>to kernel data structures.  It is commonly  mounted  at  /proc.</p><p>from Linux Manual</p></blockquote><p>通过proc文件系统可以查看有关系统硬件及当前正在运行进程的信息，也可以通过更改其中某些文件来改变内核的运行状态。很多常用的工具(e.g. <code>top</code>、<code>free</code>)都是通过访问proc中的信息来工作的。</p><h2 id="proc下的一些文件："><a href="#proc下的一些文件：" class="headerlink" title="proc下的一些文件："></a><code>proc</code>下的一些文件：</h2><ul><li><p><code>/proc/apm</code>高级电源管理（APM）版本信息及电池相关状态信息(当编译的时候<code>CONFIG_APM</code>为启用时才有效)</p></li><li><p><code>/proc/buddyinfo</code>用于诊断内存碎片问题的相关信息文件</p></li><li><p><code>/proc/interrupts</code>对于每个CPU的中断号以及中断次数</p></li><li><p><code>/proc/loadavg</code>关于CPU和磁盘I/O的负载平均值</p><pre><code class="hljs gherkin">➜  ~ cat /proc/loadavg0.63 0.77 0.85 1/156 6536  |<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">    </span>|  |<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">    </span>|  |<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">__最近一个由内核创建的进程的PID</span><span class="hljs-string">  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">_______系统当前存活的内核调度实体的数目</span><span class="hljs-string">  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  </span>|<span class="hljs-string">__________正由内核调度的实体（进程和线程）的数目</span><span class="hljs-string">  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">_____________每15秒钟  </span><span class="hljs-string">  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">__________________每5秒钟</span><span class="hljs-string">  </span>|<span class="hljs-string">_______________________每1秒钟</span></code></pre><p><strong>关于文件信息:</strong> 文件内的信息计算公式如下</p><p><code>/proc/uptime</code>系统上次启动以来的运行时间，第一个数字表示系统运行时间，第二个数字表示系统空闲时间，单位是秒。</p><p>uptime其实访问这两个文件</p><pre><code class="hljs angelscript">➜  ~ uptime <span class="hljs-number">19</span>:<span class="hljs-number">11</span>:<span class="hljs-number">47</span> up <span class="hljs-number">42</span> days,  <span class="hljs-number">3</span>:<span class="hljs-number">30</span>,  <span class="hljs-number">2</span> users,  load average: <span class="hljs-number">0.73</span>, <span class="hljs-number">0.86</span>, <span class="hljs-number">0.88</span></code></pre></li><li><p><code>/proc/meminfo</code>当前内存的利用状况等的信息，<code>free</code>访问的就是这个</p></li><li><p><code>/proc/modules</code>当前装入内核的所有模块名称列表，由<code>lsmod</code>命令使用</p></li><li><p><code>/proc/swaps</code>系统上的交换分区及其空间利用信息</p></li><li><p><code>/proc/zoneinfo</code>内存区域（zone）的详细信息列表</p></li><li><p><code>/proc/slabinfo</code>内存频繁使用的对象的cache（应该大体可以理解为系统占用的部分），该文件列出了这些对象相关slap的信息</p></li><li><p><code>/proc/stat</code>系统的一些运行信息，不同体系结构会不一样</p></li><li><p><code>/proc/vmstat</code>系统虚拟内存的多种统计数据</p></li><li><p>等等其它似乎用到的不多</p></li></ul><h2 id="进程下面的东西"><a href="#进程下面的东西" class="headerlink" title="进程下面的东西"></a>进程下面的东西</h2><p><code>proc/[num]</code>都系统进程的pid对应的状态文件，目录结构较为固定：</p><ul><li><code>cmdline</code>启动当前进程的完整命令</li><li><code>fd</code>目录包含当前进程打开的每一个文件的文件描述符（file descriptor）</li><li><code>limits</code>当前进程所使用的每一个受限资源的软限制、硬限制和管理单元</li><li><code>root</code>指向当前进程运行根目录的符号链接</li><li><code>stat</code>当前进程的状态信息</li><li><code>statm</code>进程占用内存的状态信息</li><li><code>status</code>与stat所提供信息类似，但可读性较好</li><li><code>task</code>当前进程所运行的每一个线程的相关信息</li></ul><p><strong>参考资料：</strong></p><ol><li>ecs运维指南-Linux 系统诊断[公众号：程序猿石头]</li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS相关</title>
    <link href="/posts/46833/"/>
    <url>/posts/46833/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTPS不加密什么？"><a href="#HTTPS不加密什么？" class="headerlink" title="HTTPS不加密什么？"></a>HTTPS不加密什么？</h2><p>对于TLS1.3以前的来说URL和客户端IP是不加密的。</p><h2 id="为什么不加密URL"><a href="#为什么不加密URL" class="headerlink" title="为什么不加密URL"></a>为什么不加密URL</h2><p>为了支持SNI。</p><h2 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h2><p>TLS1.3引入了”encrypted SNI”来解决这个问题。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://www.ssllabs.com/ssltest/">SSL配置测试</a></li><li><a href="https://ssl-config.mozilla.org/">SSL Configuration Generator</a></li></ul><p><strong>参考资料</strong></p><ol><li><a href="https://stackoverflow.com/questions/499591/are-https-urls-encrypted">StackOverflow: Are HTTPS URLs encrypted?</a></li><li><a href="https://https.cio.gov/faq/#why-are-domain-names-unencrypted-over-https-today">Introduction to HTTPS</a></li><li><a href="https://blog.cloudflare.com/encrypted-sni/">Encrypt it or lose it: how encrypted SNI works</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dig和host工具</title>
    <link href="/posts/62128/"/>
    <url>/posts/62128/</url>
    
    <content type="html"><![CDATA[<p>简单记录一下DNS查询的工具</p><h2 id="dig工具的使用"><a href="#dig工具的使用" class="headerlink" title="dig工具的使用"></a><code>dig</code>工具的使用</h2><p><code>dig [@global-server] [domain] [q-type] [q-class] &#123;q-opt&#125; &#123;global-d-opt&#125;</code></p><h3 id="q-type"><a href="#q-type" class="headerlink" title="q-type"></a>q-type</h3><ul><li>NS 记录：用来指定域名由哪个 DNS 服务器进行解析；</li><li>CNAME 记录：用来定义域名的别名，方便实现将多个域名解析到同一个 IP 地址；</li><li>A 记录：用来指定主机名对应的 IPv4 地址；</li><li>AAAA 记录：用来指定主机名对应的 IPv4 地址；</li><li>MX 记录：用来指定收件人域名的邮件服务器，SMTP 协议会根据 MX 记录的值来决定邮件的路由过程；</li><li>PTR 记录：常用于反向地址解析，将 IP 地址解析到对应的名称；</li><li>SOA 记录：称为起始授权机构记录，不同于 NS 记录用于标识多台域名解析服务器，SOA 记录用于在多台 NS 记录中哪一台是主 DNS 服务器。</li></ul><h3 id="常用q-opt"><a href="#常用q-opt" class="headerlink" title="常用q-opt"></a>常用q-opt</h3><ul><li><code>-x</code> 反向查询</li><li>-p 指定 DNS 查询使用的端口号，默认情况下 DNS 查询使用标准的53端口</li><li>-4 指定 dig 命令仅使用 IPv4 查询传输</li><li>-6 指定 dig 命令仅使用 IPv6 查询传输</li></ul><h3 id="常用d-opt"><a href="#常用d-opt" class="headerlink" title="常用d-opt"></a>常用d-opt</h3><ul><li><code>+short</code> 直接显示查询结果，没有返回空</li><li><code>+trace</code> 从根域名服务器开始递归式的查询并显示过程</li></ul><h3 id="结果返回SOA？"><a href="#结果返回SOA？" class="headerlink" title="结果返回SOA？"></a>结果返回SOA？</h3><ol><li>当查询的类型不存在时会在“AUTHORITY SECTION”返回SOA记录</li><li>查询的域名不存在时，会在“AUTHORITY SECTION”返回其上一层（有可能更上层，直到根）的zone的SOA记录</li></ol><h2 id="host工具"><a href="#host工具" class="headerlink" title="host工具"></a><code>host</code>工具</h2><p>使用方法： <code>host [url]</code></p><p>可以把解析记录用描述性的语言呈现出来清晰易懂。</p><p><strong>参考资料</strong></p><ol><li><a href="https://cloud.tencent.com/developer/article/1366027">dig 命令洞察 DNS 解析过程</a></li><li><a href="https://blog.csdn.net/guowenyan001/article/details/37519773">dns：逆向查询、查询返回SOA记录</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用ethtool永久修改网卡MAC地址</title>
    <link href="/posts/20682/"/>
    <url>/posts/20682/</url>
    
    <content type="html"><![CDATA[<p>偶然看到一篇文章在谈如何使用<code>ethtool</code>永久修改MAC地址，这里所谓的永久修改是指直接刷写进网卡的<code>EEPROM</code>，第一次见到这样子的操作，不知道是不是所有网卡都可以，手边也暂时没设备可以测试，先mark一下。</p><p>原文：<a href="https://blog.kanbach.org/post/how-to-permanently-change-a-mac-address-using-ethtool/">How to permanently change a MAC address using ethtool</a></p><p>先引述原作者的警告，修改错误可能会变砖，在修改前一定要记得备份！</p><blockquote><p>!! CAUTION !! Writing to the EEPROM of the network device could brick the device. Before you actually write to the EEPROM, you should backup the original EEPROM</p></blockquote><p>TL;DR</p><p>备份：<code>$ ethtool -e eth0 raw on &gt; eeprom-backup.bin</code></p><p>写入：<code>$ ethtool -E eth0 magic &lt;N&gt; offset &lt;N&gt; value &lt;N&gt;</code></p><p>详细步骤及内容请参阅作者原文以及<code>ethtool</code>的manual。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim速查表</title>
    <link href="/posts/40855/"/>
    <url>/posts/40855/</url>
    
    <content type="html"><![CDATA[<h2 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h2><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>x</code></td><td style="text-align:center">删除一个字母</td></tr><tr><td style="text-align:center"><code>d</code></td><td style="text-align:center">删除</td></tr><tr><td style="text-align:center"><code>dd</code></td><td style="text-align:center">删除一行</td></tr><tr><td style="text-align:center"><code>u</code></td><td style="text-align:center">撤销</td></tr><tr><td style="text-align:center"><code>U</code></td><td style="text-align:center">撤销整行</td></tr><tr><td style="text-align:center"><code>Ctrl+R</code></td><td style="text-align:center">重做</td></tr><tr><td style="text-align:center"><code>p</code></td><td style="text-align:center">粘贴</td></tr><tr><td style="text-align:center"><code>r</code></td><td style="text-align:center">替换</td></tr><tr><td style="text-align:center"><code>ce</code></td><td style="text-align:center">更改</td></tr></tbody></table></div><h2 id="motion"><a href="#motion" class="headerlink" title="motion"></a>motion</h2><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>w</code></td><td style="text-align:center">下一个单词起始位置</td></tr><tr><td style="text-align:center"><code>e</code></td><td style="text-align:center">单词末尾</td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">行末</td></tr></tbody></table></div><p>注: num+motion可以重复执行。e.g. <code>2dd</code>会删除两行</p><h2 id="跳转类"><a href="#跳转类" class="headerlink" title="跳转类"></a>跳转类</h2><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>(num)+G</code></td><td style="text-align:center">(前往第num行)或行尾</td></tr><tr><td style="text-align:center"><code>gg</code></td><td style="text-align:center">首行</td></tr><tr><td style="text-align:center"><code>:(num)</code></td><td style="text-align:center">前往第num行</td></tr></tbody></table></div><h2 id="查找类"><a href="#查找类" class="headerlink" title="查找类"></a>查找类</h2><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center">向前查找</td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">向后查找</td></tr><tr><td style="text-align:center"><code>%</code></td><td style="text-align:center">找配对括号</td></tr></tbody></table></div><h2 id="替换类"><a href="#替换类" class="headerlink" title="替换类"></a>替换类</h2><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>:s/old/new</code></td><td style="text-align:center">替换一处</td></tr><tr><td style="text-align:center"><code>:s/old/new/g</code></td><td style="text-align:center">替换<strong>一行</strong>里的所有</td></tr><tr><td style="text-align:center"><code>:#,#s/old/new/g</code></td><td style="text-align:center">替换#行和#行之间的</td></tr><tr><td style="text-align:center"><code>:%s/old/new/g</code></td><td style="text-align:center">替换<strong>文件</strong>里的所有</td></tr><tr><td style="text-align:center"><code>:%s/old/new/gc</code></td><td style="text-align:center">交互式替换(每一个都问下要不要换)</td></tr></tbody></table></div><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>:Ctrl+D</code></td><td style="text-align:center">自动补全命令</td></tr><tr><td style="text-align:center"><code>:!命令</code></td><td style="text-align:center">执行命令</td></tr><tr><td style="text-align:center"><code>:w+名字</code></td><td style="text-align:center">另存为</td></tr><tr><td style="text-align:center"><code>r</code></td><td style="text-align:center">提取文件/输出</td></tr><tr><td style="text-align:center"><code>o</code></td><td style="text-align:center">打开新一行</td></tr></tbody></table></div><h2 id="插入类"><a href="#插入类" class="headerlink" title="插入类"></a>插入类</h2><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>a</code></td><td style="text-align:center">光标后插入</td></tr><tr><td style="text-align:center"><code>i</code></td><td style="text-align:center">光标处插入</td></tr><tr><td style="text-align:center"><code>A</code></td><td style="text-align:center">行末插入</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>速查表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iptables笔记</title>
    <link href="/posts/44305/"/>
    <url>/posts/44305/</url>
    
    <content type="html"><![CDATA[<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="关于Netfilter"><a href="#关于Netfilter" class="headerlink" title="关于Netfilter"></a>关于<code>Netfilter</code></h3><p>首先防火墙的实现是基于Linux内核中的<code>Netfilter</code>模块的，该框架在网络数据包处理的五个节点（如下表）插入hook函数进而干预ip数据包的转发处理过程。</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">PREROUTING</td><td style="text-align:center">路由判断之前的阶段</td></tr><tr><td style="text-align:center">INPUT</td><td style="text-align:center">路由判断后如果是自己的则进入该节点</td></tr><tr><td style="text-align:center">FORWARD</td><td style="text-align:center">路由判断后如果是不是自己的包则进入该节点</td></tr><tr><td style="text-align:center">OUTPUT</td><td style="text-align:center">上层处理完毕后返回处理结果发出去时经过的节点</td></tr><tr><td style="text-align:center">POSTROUTING</td><td style="text-align:center">INPUT和FORWARD都会经过的节点</td></tr></tbody></table></div><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjfzztumfmj30qm0c00st.jpg" alt="各节点位置及流程图" style="zoom:80%;" /></p><h3 id="关于iptables"><a href="#关于iptables" class="headerlink" title="关于iptables"></a>关于<code>iptables</code></h3><p><code>iptables</code>是运行在用户空间的用来管理和配置<code>Netfilter</code>的软件。</p><p><a href="https://www.netfilter.org/projects/iptables/index.html">iptables网站</a></p><h3 id="关于dfw和firewalld"><a href="#关于dfw和firewalld" class="headerlink" title="关于dfw和firewalld"></a>关于<code>dfw</code>和<code>firewalld</code></h3><p>两者是基于iptables或者nftables的管理软件，用于更方便的进行配置管理，具体不同发行版有所差异。</p><h2 id="iptables的结构"><a href="#iptables的结构" class="headerlink" title="iptables的结构"></a>iptables的结构</h2><p>iptables包含四表五链，每个表包含几种链，关于<a href="http://www.zsythink.net/archives/1199">表和链的更多讲解</a>。</p><p>四表的优先级为raw–&gt;mangle–&gt;nat–&gt;filter。</p><h3 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h3><p>包含<code>PREROUTING</code>和<code>POSTROUTING</code>不常用略去。</p><h3 id="mangle"><a href="#mangle" class="headerlink" title="mangle"></a>mangle</h3><p>默认五条链都包括，用于修改数据包</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>用于处理过滤过程，主要包含三条链</p><ul><li>INPUT 链：过滤所有目标地址是本机的数据包</li><li>FORWARD 链：过滤所有路过本机的数据包</li><li>OUTPUT 链：过滤所有由本机产生的数据包</li></ul><h3 id="nat"><a href="#nat" class="headerlink" title="nat"></a>nat</h3><p>处理网络地址转换，可以进行 Snat（改变数据包的源地址）、Dnat（改变数据包的目标地址）</p><ul><li>PREROUTING 链：可以在数据包到达防火墙时改变目标地址</li><li>OUTPUT 链：可以改变本地产生的数据包的目标地址</li><li>POSTROUTING 链：在数据包离开防火墙时改变数据包的源地址</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjg17jolq4j30xr0dsaag.jpg" style="zoom:80%;" alt="整体结构" /></p><p>一般处理流程：</p><ol><li>数据包进入的时候，先进 mangle 表的 PREROUTING 链。在这里可以根据需要，改变数据包头内容之后，进入 nat 表的 PREROUTING 链，在这里可以根据需要做 Dnat，也就是目标地址转换。</li><li>进入路由判断，判断是进入本地的还是转发的。</li><li>如果是进入本地的，就进入 INPUT 链，之后按条件过滤限制进入。</li><li>之后进入本机，再进入 OUTPUT 链，按条件过滤限制出去，离开本地。</li><li>如果是转发就进入 FORWARD 链，根据条件过滤限制转发。</li><li>之后进入 POSTROUTING 链，这里可以做 Snat，离开网络接口。</li></ol><p><strong>参考资料</strong></p><p>1 <a href="https://medium.com/@iced_burn/compare-firewalld-iptables-nftables-netfilter-de08a8d21b5b">Compare: Firewalld / Iptables / Nftables / Netfilter</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas速查表</title>
    <link href="/posts/5186/"/>
    <url>/posts/5186/</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据结构操作"><a href="#基本数据结构操作" class="headerlink" title="基本数据结构操作"></a>基本数据结构操作</h1><div class="table-container"><table><thead><tr><th><strong>维数</strong></th><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td>Series</td><td>带标签的一维同构数组</td></tr><tr><td>2</td><td>DataFrame</td><td>带标签的，大小可变的，二维异构表格</td></tr></tbody></table></div><p>DataFrame 是 Series 的容器，Series 则是标量的容器。使用这种方式，可以在容器中以字典的形式插入或删除对象。</p><h2 id="df的基本操作"><a href="#df的基本操作" class="headerlink" title="df的基本操作"></a>df的基本操作</h2><ol><li><p><code>df[col]</code>这样子取得的是列</p></li><li><p><code>df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list(&#39;ABCD&#39;))</code></p></li></ol><ol><li><p><code>df.head(2)</code></p><p><code>df.tail(3)</code></p><p><code>df.index</code></p><p><code>df.column</code></p></li><li><p><code>df.to_numpy()</code>可以转换为numpy</p></li><li><p><code>df.describe()</code>可以查看统计信息</p></li><li><p><code>df.T</code>转置</p></li><li><p><code>df.sort_index(axis=1, ascending=False)</code>按轴排序</p></li><li><p><code>df.sort_values(by=&#39;B&#39;)</code></p></li></ol><h2 id="选择数据"><a href="#选择数据" class="headerlink" title="选择数据"></a>选择数据</h2><ol><li><code>df[&#39;A&#39;]</code>选择单列</li><li><code>df[0:3]</code>切片行</li><li>按照标签选择df.loc[]选择一行</li><li><code>df.loc[:, [&#39;A&#39;, &#39;B&#39;]]</code>选择多个列</li><li>选择范围就是组合应用上面的过程</li><li><code>df.at[]</code>访问数据和上面的结果一样</li><li><code>df.iloc[]</code>按照索引选择数据</li><li>布尔索引<code>df[df.A &gt; 0]</code></li></ol><p>e.g.操作示范</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> df.columns:    series = df[col]    <span class="hljs-comment"># do something with series</span></code></pre><h1 id="显示控制"><a href="#显示控制" class="headerlink" title="显示控制"></a>显示控制</h1><pre><code class="hljs python"><span class="hljs-comment">#显示所有的列</span>pd.set_option(<span class="hljs-string">&#x27;display.max_columns&#x27;</span>, <span class="hljs-literal">None</span>)<span class="hljs-comment">#显示所有的行</span>pd.set_option(<span class="hljs-string">&#x27;display.max_rows&#x27;</span>, <span class="hljs-literal">None</span>)<span class="hljs-comment">#设置value的显示长度为100，默认为50</span>pd.set_option(<span class="hljs-string">&#x27;max_colwidth&#x27;</span>,<span class="hljs-number">100</span>)</code></pre><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="1-分组去重复统计"><a href="#1-分组去重复统计" class="headerlink" title="1. 分组去重复统计"></a><a href="https://blog.csdn.net/weixin_43609275/article/details/86220907">1. 分组去重复统计</a></h2><p> <code>df.groupby(&#39;param&#39;)[&#39;group&#39;].nunique()</code></p><h2 id="2-去重"><a href="#2-去重" class="headerlink" title="2. 去重"></a>2. 去重</h2><p><code>data.drop_duplicates(subset=[&#39;A&#39;,&#39;B&#39;],keep=&#39;first&#39;,inplace=True)</code></p><h2 id="3-按日期字段分组"><a href="#3-按日期字段分组" class="headerlink" title="3. 按日期字段分组"></a>3. 按日期字段分组</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd data = pd.read_csv(<span class="hljs-string">&#x27;xxx.csv&#x27;</span>)data[<span class="hljs-string">&#x27;index&#x27;</span>] = pd.to_datetime(data[<span class="hljs-string">&#x27;index&#x27;</span>])print(data.groupby([data[<span class="hljs-string">&#x27;index&#x27;</span>].dt.year, data[<span class="hljs-string">&#x27;index&#x27;</span>].dt.month]).mean())print(data.groupby([data[<span class="hljs-string">&#x27;index&#x27;</span>].dt.year, data[<span class="hljs-string">&#x27;index&#x27;</span>].dt.month]).last())</code></pre><h2 id="4-PANDAS-数据合并与重塑"><a href="#4-PANDAS-数据合并与重塑" class="headerlink" title="4. PANDAS 数据合并与重塑"></a><a href="https://blog.csdn.net/weixin_37226516/article/details/64134643">4. PANDAS 数据合并与重塑</a></h2><h2 id="5-使用自定义函数处理数据"><a href="#5-使用自定义函数处理数据" class="headerlink" title="5. 使用自定义函数处理数据"></a>5. 使用自定义函数处理数据</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equal_word</span>(<span class="hljs-params">B,A</span>):</span> <span class="hljs-comment"># A -&gt;关键词   B-&gt;品牌词</span>    A,B=<span class="hljs-built_in">str</span>(A),<span class="hljs-built_in">str</span>(B)        <span class="hljs-keyword">if</span> B <span class="hljs-keyword">in</span> A :          <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment">#如果包含，返回False</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment">#如果不包含，则返回True</span>df2=df1[[<span class="hljs-string">&#x27;S_key_word&#x27;</span>,<span class="hljs-string">&#x27;S_brand&#x27;</span>]]df1[<span class="hljs-string">&#x27;bool&#x27;</span>]=df2.apply(<span class="hljs-keyword">lambda</span> x :equal_word(x[<span class="hljs-string">&#x27;S_brand&#x27;</span>] ,x[<span class="hljs-string">&#x27;S_key_word&#x27;</span>]),axis=<span class="hljs-number">1</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决网易163邮箱`Unsafe Login.`错误</title>
    <link href="/posts/45207/"/>
    <url>/posts/45207/</url>
    
    <content type="html"><![CDATA[<p>在尝试使用IMAP协议连接网易163邮箱后尝试读取收件箱时服务器返回<code>Unsafe Login. Please contact kefu@188.com for help</code>报错。</p><p>网上广为流传的解决方案是使用神秘网址<code>http://config.mail.163.com/settings/imap/index.jsp?uid=xxxxxx@163.com</code>进行设置。经过测试该方法已经失效了，不必再做尝试。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>经过邮件询问报错原因是发送请求时没有包含imap id，回复如下：</p><blockquote><p>关于您反馈的客户端问题，经核实，关于您反馈的客户端添加网易邮箱帐号出现的收信问题，经反馈核实是第三方客户端没有带imap id被判断为不安全登录，系统为了用户安全自动阻止该类登录。</p></blockquote><p><code>IMAP ID</code>是在RFC2971中定义的一个扩展IMAP指令，详情查阅<a href="https://www.ietf.org/rfc/rfc2971.txt">该文档</a></p><p>对于我程序所使用的python <code>imapcilent</code>库来说，在<code>login</code>之后<code>select</code>文件夹之前使用文档中所述的<code>id_</code>方法向服务器发送<code>ID</code>命令客户端信息即可，<a href="https://imapclient.readthedocs.io/en/2.1.0/api.html#imapclient.IMAPClient.id_">文档链接</a></p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> imapclient <span class="hljs-keyword">import</span> IMAPClientserver = IMAPClient(<span class="hljs-string">&quot;imap.163.com&quot;</span>, ssl=<span class="hljs-literal">True</span>, port=<span class="hljs-number">993</span>)server.login(<span class="hljs-string">&quot;&lt;user&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;passwd&gt;&quot;</span>)server.id_(&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;IMAPClient&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.1.0&quot;</span>&#125;)messages = server.select_folder(<span class="hljs-string">&#x27;INBOX&#x27;</span>)</code></pre><h2 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h2><p>从定义来看这个<code>ID</code>扩展只是客户端对自己身份的单方面声明而已，根本没有办法进行任何验证，不大能理解为什么要把不带这一字段的判断为不安全，另外在RFC2971的<code>3. Specification</code>中对于用途也有下面的说明：</p><blockquote><p>The sole purpose of the ID extension is to enable clients and servers<br>to exchange information on their implementations for the purposes of<br>statistical analysis and problem determination.</p></blockquote><p>以及</p><blockquote><p>Servers MUST NOT deny access to or refuse service for a client<br>based on information from the ID command.  Clients MUST NOT refuse<br>to operate or limit their operation with a server based on the ID<br>response.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IMAP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Outlook和163邮箱IMAP、SMTP踩坑</title>
    <link href="/posts/55107/"/>
    <url>/posts/55107/</url>
    
    <content type="html"><![CDATA[<p>为了收作业想弄个自动收邮件+下载附件的东西放到阿里云Serverless上跑，邮箱选择的是Outlook，配置IMAP登录的时候遇到几个问题记录一下。</p><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p><code>python3.7</code> <code>Microsoft 365 Outlook</code></p><h2 id="Outlook-IMAP-login-fail"><a href="#Outlook-IMAP-login-fail" class="headerlink" title="Outlook IMAP login fail"></a>Outlook IMAP login fail</h2><p>没有任何其他错误返回，就是<code>login faild</code>，迷惑好久，网上的各种资料都说不到点子上。最后意识到是两步验证的问题，创建应用密码可以解决</p><p>说明文档：<a href="https://support.microsoft.com/zh-cn/help/12409/microsoft-account-app-passwords-and-two-step-verification">对不支持双重验证的应用使用应用密码</a></p><h2 id="Outlook-SMTP-发信失败"><a href="#Outlook-SMTP-发信失败" class="headerlink" title="Outlook SMTP 发信失败"></a>Outlook SMTP 发信失败</h2><p><code>Failed to process message due to a permanent exception with message Recipientisn\&#39;t resolved</code></p><p>收件人部分不要使用<code>utf-8</code>编码即可解决</p><h2 id="迷惑的163"><a href="#迷惑的163" class="headerlink" title="迷惑的163"></a>迷惑的163</h2><p><code>NO SELECT Unsafe Login. Please contact kefu@188.com for help</code></p><p>Outlook的<code>login faild</code>是在太让人迷惑以至于我尝试了一下163，发现结果更加扯淡，我尝试联系了<code>kefu@188.com</code><del>至今未果</del>，不过意外发现网易账号支持注销了emmmm</p><p>注销地址：<a href="https://m.reg.163.com/">网易账号中心</a> 点击注销照着操作就行</p><p>update: 发完邮件就给忘了，今天打开邮箱发现收到回复了，感谢客服的及时回复，解决方案见<a href="https://blog.yrpang.com/posts/45207/">这篇文章</a></p><h2 id="如何建立starttls连接"><a href="#如何建立starttls连接" class="headerlink" title="如何建立starttls连接"></a>如何建立<code>starttls</code>连接</h2><p>outlook的smtp服务器使用的是starttls连接，使用python标准库建立连接的方法如下。</p><pre><code class="hljs python">sender = smtplib.SMTP(<span class="hljs-string">&#x27;outlook.office365.com&#x27;</span>, <span class="hljs-number">587</span>)sender.starttls()sender.login(<span class="hljs-string">&quot;&lt;user&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;passwd&gt;&quot;</span>)</code></pre><h2 id="关于邮件处理脚本"><a href="#关于邮件处理脚本" class="headerlink" title="关于邮件处理脚本"></a>关于邮件处理脚本</h2><p>目前是基于阿里云Serverless+OSS做的，异常处理还不够完善，也没有友好的收集进度显示，近期找时间完善下再放出来，到时也欢迎有需求的课代表们体验。记得Star（逃。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Serverless</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>torch.nn.function的一些参数</title>
    <link href="/posts/54034/"/>
    <url>/posts/54034/</url>
    
    <content type="html"><![CDATA[<p>本文用于随手记录我在学习ML的过程中用到的<code>Pytorch</code>函数中参数的含义和一些注意。</p><h2 id="1-Conv2d"><a href="#1-Conv2d" class="headerlink" title="1 Conv2d"></a>1 <code>Conv2d</code></h2><p>这个要注意的它的padding是双向的，也就是补2倍的0</p>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/posts/46563/"/>
    <url>/posts/46563/</url>
    
    <content type="html"><![CDATA[<p>简单记录正则表达式常用内容</p><h2 id="源字符"><a href="#源字符" class="headerlink" title="源字符"></a>源字符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">源字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">除换行符以外的任意字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">字母、数字、下划线、汉字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">任意空白字符</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">任意数字</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">单词的开始或结束</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">字符串开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">字符串结束</td></tr></tbody></table></div><h2 id="控制重复"><a href="#控制重复" class="headerlink" title="控制重复"></a>控制重复</h2><div class="table-container"><table><thead><tr><th style="text-align:center">控制符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">任意次</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">>=1次</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">0/1次</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">n次</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">>=n次</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">n~m次</td></tr></tbody></table></div><h2 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h2><p>pcretest pcre提供的一个小工，用来测试正则表达式</p><pre><code class="hljs bash">brew install pcre</code></pre>]]></content>
    
    
    <categories>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习笔记（二）</title>
    <link href="/posts/39867/"/>
    <url>/posts/39867/</url>
    
    <content type="html"><![CDATA[<p>http模块的配置指令</p><h2 id="前期准备阶段（框架代码处理）"><a href="#前期准备阶段（框架代码处理）" class="headerlink" title="前期准备阶段（框架代码处理）"></a>前期准备阶段（框架代码处理）</h2><h3 id="listen语句"><a href="#listen语句" class="headerlink" title="listen语句"></a>listen语句</h3><p>文档 <a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#listen">https://nginx.org/en/docs/http/ngx_http_core_module.html#listen</a></p><p><strong>用sock和本地端口的区别</strong></p><p>通过sock不需要走Linux完整网络模型速度更快</p><h3 id="server-name语句"><a href="#server-name语句" class="headerlink" title="server_name语句"></a>server_name语句</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li><p>指定多个域名，第一个为<strong>主域名</strong></p><blockquote><p>Syntax: server_name_in_redirect on | off;<br>Default: server_name_in_redirect off;<br>Context: http, server, location</p></blockquote></li></ul><p>主域名的作用是当<code>server_name_in_redirect</code>设置为<code>on</code> 的时候重定向会将domain改为主域名</p><p>e.g.</p><pre><code class="hljs nginx">server&#123;  <span class="hljs-attribute">server_name</span> primary.test.com second.test.com;<span class="hljs-attribute">server_name_in_redirect</span> <span class="hljs-literal">on</span>;    <span class="hljs-attribute">return</span> <span class="hljs-number">302</span> /redirect;  &#125;</code></pre><p>这样在返回的时候会重定向到<code>http://primary.test.com/redirect</code></p><ul><li><p>泛域名</p><p>*.test.com </p><p>test.com/*</p><p>只支持在最前或最后</p></li><li><p>正则表达式</p><p>加前缀~^test/.com\/\d{2}$</p><p>正则表达式可以使用()创建变量</p><p>e.g.</p><pre><code class="hljs nginx">server&#123;  <span class="hljs-attribute">server_name</span> ~^(www\.)?(.+);  <span class="hljs-attribute">location</span> / &#123;    <span class="hljs-attribute">root</span> /site/<span class="hljs-variable">$2</span>;  &#125;&#125;</code></pre></li><li><p>其它</p><ul><li><code>.test.com</code> 可以用来匹配<code>test.com</code> 和<code>*.test.com</code></li><li><code>_</code>匹配所有</li><li><code>&quot;&quot;</code> 匹配没有传递<code>Host</code> 头部的</li></ul></li></ul><h4 id="匹配顺序"><a href="#匹配顺序" class="headerlink" title="匹配顺序"></a>匹配顺序</h4><ol><li>精确匹配</li><li>*在前的泛域名</li><li>*在后的泛域名</li><li>正则表达式匹配(多次匹配的按照顺序进行选择)</li><li>匹配失败 —&gt; default server<ul><li>不指定则为第一个</li><li>listen语句可以用default指定</li></ul></li></ol><h2 id="Http请求的11个阶段"><a href="#Http请求的11个阶段" class="headerlink" title="Http请求的11个阶段"></a>Http请求的11个阶段</h2><div class="table-container"><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:center">模块</th></tr></thead><tbody><tr><td style="text-align:center">POST_READ</td><td style="text-align:center">realip</td></tr><tr><td style="text-align:center">SERVER_REWRITE</td><td style="text-align:center">rewrite</td></tr><tr><td style="text-align:center">FIND_CONFIG</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">REWRITE</td><td style="text-align:center">rewrite</td></tr><tr><td style="text-align:center">POST_REWRITE</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">PREACCESS</td><td style="text-align:center">limt_conn, limt_req</td></tr><tr><td style="text-align:center">ACCESS</td><td style="text-align:center">auth_basic, access, auth_request</td></tr><tr><td style="text-align:center">POST_ACCESS</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">PRECONTENT</td><td style="text-align:center">try_files</td></tr><tr><td style="text-align:center">CONTENT</td><td style="text-align:center">Index, autoindex, concat</td></tr><tr><td style="text-align:center">LOG</td><td style="text-align:center">access_log</td></tr></tbody></table></div><h2 id="rewrite模块"><a href="#rewrite模块" class="headerlink" title="rewrite模块"></a>rewrite模块</h2><h3 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h3><pre><code class="hljs nginx"><span class="hljs-attribute">return</span> code [text]return code URLreturn URL</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">标准</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">301</td><td style="text-align:center">http1.0</td><td style="text-align:center">永久重定向</td></tr><tr><td style="text-align:center">302</td><td style="text-align:center">http1.0</td><td style="text-align:center">临时重定向，禁止缓存</td></tr><tr><td style="text-align:center">303</td><td style="text-align:center">http1.1</td><td style="text-align:center">临时重定向，禁止缓存，<strong>允许</strong>改变方法</td></tr><tr><td style="text-align:center">307</td><td style="text-align:center">http1.1</td><td style="text-align:center">临时重定向，禁止缓存，<strong>不允许</strong>改变方法</td></tr><tr><td style="text-align:center">308</td><td style="text-align:center">http1.1</td><td style="text-align:center">永久重定向，不允许改变方法</td></tr><tr><td style="text-align:center">444</td><td style="text-align:center">nginx自定义</td><td style="text-align:center">立即关闭连接，不反回数据</td></tr></tbody></table></div><h3 id="error-page指令"><a href="#error-page指令" class="headerlink" title="error_page指令"></a>error_page指令</h3><pre><code class="hljs nginx">1. error_page 404 /404.html;2. error_page 500 502 503 504 /50x.html;3. error_page 404 =200 /empty.gif;4. error_page 404 = /404.php;5. location / &#123;<span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> = <span class="hljs-variable">@fallback</span>; &#125;<span class="hljs-attribute">location</span> <span class="hljs-variable">@fallback</span> &#123;<span class="hljs-attribute">proxy_pass</span> http://backend;&#125;6. error_page 403 http://example.com/forbidden.html;7. error_page 404 =301 http://example.com/notfound.html</code></pre><p>rewrite指令在两个阶段都可能出现，此时要注意执行顺序</p><h3 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h3><blockquote><p>Syntax: rewrite regex replacement [flag];</p></blockquote><ul><li><p>作用是将regex替换成replacement</p></li><li><p>regex可以使用正则表达式和分组生成新变量</p></li><li><p>如果relacement以<code>http://</code>或<code>https://</code> 或<code>$schema</code> 开头直接返回302</p></li><li><p>flag：</p><p>|   flag    |                    意义                    |<br>| :———-: | :————————————————————: |<br>|   last    |     用replacement进行新的location匹配      |<br>|   break   | 停止当前脚本的执行,停止rewrite模块其他指令 |<br>| redirect  |               返回302重定向                |<br>| permanent |               返回301重定向                |</p><p><img src="https://myblog-1254913510.file.myqcloud.com/ojl2j.png" style="zoom:50%;" /></p><p>1 会按顺序执行</p><p>2 返回3.txt的内容  返回3.txt的内容 返回”third”</p><p>3 emmm</p></li></ul><pre><code class="hljs nginx"><span class="hljs-attribute">rewrite_log</span> <span class="hljs-literal">on</span>error_log ...</code></pre><p>开启可以记录下所有重定向记录</p><h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><p><img src="https://myblog-1254913510.file.myqcloud.com/flew1.png" style="zoom:50%;" /></p><h2 id="find-config-阶段-location-指令"><a href="#find-config-阶段-location-指令" class="headerlink" title="find_config 阶段 location 指令"></a>find_config 阶段 location 指令</h2><blockquote><p>Syntax:    <code>location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</code><br>location @name { … }<br>Default:    —<br>Context:    server, location</p><p>Syntax:    merge_slashes on | off;<br>Default:<br>merge_slashes on;<br>Context:    http, server</p></blockquote><p>URL常见有有如下几种</p><ol><li>前缀字符串<ol><li>常规</li><li>=：精确匹配</li><li>^~：匹配上后则不再进行正则匹配</li></ol></li><li>正则表达式<ol><li>~：大小写敏感</li><li>~*：忽略大小写</li></ol></li><li>用于内部跳转的命名：@name</li><li>合并连续的/号：<code>merge_slashes on</code></li></ol><h3 id="匹配顺序："><a href="#匹配顺序：" class="headerlink" title="匹配顺序："></a>匹配顺序：</h3><p><img src="https://myblog-1254913510.file.myqcloud.com/0do7t.png" style="zoom:50%;" /></p><p>首先进行前缀匹配，发现<code>=</code>或者<code>^~</code>匹配则直接使用，否则记住最长匹配，按文件顺序进行正则表达式匹配，匹配则直接采用否则继续匹配，若均不匹配则使用上面记录的最长匹配。</p><h2 id="PREACCESS阶段"><a href="#PREACCESS阶段" class="headerlink" title="PREACCESS阶段"></a>PREACCESS阶段</h2><h3 id="limit-conn模块-限制并发连接数"><a href="#limit-conn模块-限制并发连接数" class="headerlink" title="limit_conn模块(限制并发连接数)"></a>limit_conn模块(限制并发连接数)</h3><p>默认编译</p><p>使用共享内存，生效于全部worker</p><p>限制有效性取决于key的设计：postread阶段的realip模块获得的真实ip</p><p>主要指令：</p><ol><li><p>定义共享内存以及key</p><p><code>limit_conn_zone key zone=name:size</code></p><p>key可以取<code>$remote_addr</code> <code>binary_remote_addr</code>等</p></li><li><p><code>limit_conn zone number</code></p></li></ol><p>日志相关指令：</p><p><code>limit_con_log_level</code>控制日志级别</p><p><code>limit_conn_status</code>控制返回错误码</p><h3 id="limit-request模块-限制每个客户端每秒请求数"><a href="#limit-request模块-限制每个客户端每秒请求数" class="headerlink" title="limit_request模块(限制每个客户端每秒请求数)"></a>limit_request模块(限制每个客户端每秒请求数)</h3><p>默认编译</p><p>使用共享内存，生效于全部worker</p><p>算法：leaky bucket算法</p><p>主要指令：</p><ol><li><p>定义共享内存<code>limit_req_zone key zone=name:size rate=rate ;</code></p></li><li><p>限制并发连接数<code>limit_req zone=name [burst=number] [nodelay];</code></p><ul><li>burst默认为0</li><li>nodelay立即处理不做延时</li></ul></li></ol><p>日志相关: <code>limit_req_log_level</code>和<code>limit_conn_status</code></p><p><strong>另：同时打开时<code>limit_request模块</code>优先生效</strong></p><h2 id="ACCESS阶段"><a href="#ACCESS阶段" class="headerlink" title="ACCESS阶段"></a>ACCESS阶段</h2><h3 id="access模块"><a href="#access模块" class="headerlink" title="access模块"></a>access模块</h3><p>指令：</p><p><code>allow</code>和<code>deny</code></p><h3 id="auth-basic模块"><a href="#auth-basic模块" class="headerlink" title="auth_basic模块"></a>auth_basic模块</h3><p>用户认证模块</p><p><code>auth_basic</code>和<code>auth_basic_user_file</code></p><h3 id="auth-request使用第三方权限验证系统-默认未编译"><a href="#auth-request使用第三方权限验证系统-默认未编译" class="headerlink" title="auth_request使用第三方权限验证系统(默认未编译)"></a>auth_request使用第三方权限验证系统(默认未编译)</h3><p><code>auth_request</code>和<code>auth_request_set</code></p><h3 id="对上面三个模块做限制的satisfy指令"><a href="#对上面三个模块做限制的satisfy指令" class="headerlink" title="对上面三个模块做限制的satisfy指令"></a>对上面三个模块做限制的<code>satisfy</code>指令</h3><p><code>satisfy all | any;</code></p><p>all:必须所有模块放行才可以</p><p>any:任何一个放行就可以</p><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><ol><li>如果有return则不生效，即使在前面也不生效</li><li>模块间顺序有影响</li></ol><p><img src="https://myblog-1254913510.file.myqcloud.com/ybba0.png" style="zoom:50%;"/></p><h2 id="PRECONTENT阶段"><a href="#PRECONTENT阶段" class="headerlink" title="PRECONTENT阶段"></a>PRECONTENT阶段</h2><h3 id="try-files指令"><a href="#try-files指令" class="headerlink" title="try_files指令"></a>try_files指令</h3><p>依次试图访问各个文件[没有的话返回code]<code>try_files file ... [=code];</code></p><p>应用：反向代理时可以先尝试在本地找，没有的话去上游</p><h3 id="mirror模块"><a href="#mirror模块" class="headerlink" title="mirror模块"></a>mirror模块</h3><p>流量拷贝</p><p>处理请求时，生成子请求访问其他服务，对子请求的返回值不做请求</p><p><code>mirror</code>和<code>mirror_request_body</code></p><h2 id="CONTENT阶段"><a href="#CONTENT阶段" class="headerlink" title="CONTENT阶段"></a>CONTENT阶段</h2><h3 id="static模块-root和alias模块"><a href="#static模块-root和alias模块" class="headerlink" title="static模块(root和alias模块)"></a>static模块(root和alias模块)</h3><h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>将url映射为静态文件提供访问</p><h4 id="root和alias之间的差别："><a href="#root和alias之间的差别：" class="headerlink" title="root和alias之间的差别："></a>root和alias之间的差别：</h4><ol><li>root会将location映射进文件路径，alias只会将location后的url映射</li><li>root有默认配置<code>html</code></li><li>content只能用在location里,root有上下文可以继承上文</li></ol><p>例子<br><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /root&#123;  <span class="hljs-attribute">root</span> html;&#125;<span class="hljs-attribute">loaction</span> /alias&#123;  <span class="hljs-attribute">alias</span> html&#125;</code></pre></p><p>则访问<code>/root</code>会访问<code>html/root</code>，<code>/alias</code>则是<code>/html</code></p><h4 id="几个变量"><a href="#几个变量" class="headerlink" title="几个变量"></a>几个变量</h4><div class="table-container"><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">request_filename</td><td style="text-align:center">待访问文件完整路径</td></tr><tr><td style="text-align:center">document_root</td><td style="text-align:center">由URL和root/alias规则生成的文件夹路径</td></tr><tr><td style="text-align:center">realpath_root</td><td style="text-align:center">将document_root替换为真实路径(解决软连接等)</td></tr></tbody></table></div><h4 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h4><p><img src="https://myblog-1254913510.file.myqcloud.com/xl6zt.png" style="zoom:50%;"/></p><p>日志：<code>log_not_found on|off</code></p><h4 id="当访问目标是目录但是没有带-的处理"><a href="#当访问目标是目录但是没有带-的处理" class="headerlink" title="当访问目标是目录但是没有带/的处理"></a>当访问目标是目录但是没有带<code>/</code>的处理</h4><p>会触发301重定向</p><p><code>server_name_in_redirect on|off</code> 控制是否返回server_name</p><p><code>port_in_redirect on|off</code> 是否附加端口</p><p><code>absolute_redirect on|off</code> 控制是否返回域名 打开但是<code>server_name</code>为<code>off</code>时返回<code>host</code></p><h3 id="index和auto-index"><a href="#index和auto-index" class="headerlink" title="index和auto_index"></a>index和auto_index</h3><p>当以<code>/</code>结尾时，默认<code>index</code>尝试寻找<code>index.html</code>，<code>auto_index</code>则尝试返回目录</p><p>然而因为<code>index</code>领先<code>auto_index</code>，所以如果目录下存在<code>index</code>指定的文件时就不会返回目录</p><p>一些指令<code>autoindex</code> <code>autoindex_exact_size</code> <code>autoindex_format</code> <code>autoindex_localtime</code></p><h3 id="concat模块"><a href="#concat模块" class="headerlink" title="concat模块"></a>concat模块</h3><p>功能：<br>当页面需要访问多个小文件时，拼接返回提高性能，由阿里巴巴提供</p><p>使用:<br>下载<a href="https://github.com/alibaba/nginx-http-concat">https://github.com/alibaba/nginx-http-concat</a><br>编译时添加<code>--add-module=../nginx-http-concat/</code></p><p><img src="https://myblog-1254913510.file.myqcloud.com/e0gj3.png" style="zoom:50%;"/></p><p>未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习笔记（一）</title>
    <link href="/posts/3009/"/>
    <url>/posts/3009/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近看陶辉老师的「Nginx核心知识100讲」做一些笔记，记录一些实用的配置和操作。</p><p>本篇记录nginx基本架构的讲解。</p></blockquote><h2 id="Mark一个日志监控程序"><a href="#Mark一个日志监控程序" class="headerlink" title="Mark一个日志监控程序"></a>Mark一个日志监控程序</h2><p>Mark一个可视化的日志监控程序<a href="https://goaccess.io/">GoAccess</a></p><h2 id="使用信号管理父子进程"><a href="#使用信号管理父子进程" class="headerlink" title="使用信号管理父子进程"></a>使用信号管理父子进程</h2><p>Nginx的进程包含master进程和worker进程，它们都是通过信号进行管理的，平时通过<code>nginx -s command</code>来进行管理实际上是同样的原理。</p><p>它们可以接收的信号及对应操作如下</p><h3 id="Master进程（管理worker进程）"><a href="#Master进程（管理worker进程）" class="headerlink" title="Master进程（管理worker进程）"></a>Master进程（管理worker进程）</h3><div class="table-container"><table><thead><tr><th style="text-align:center">信号</th><th style="text-align:center">功能</th><th style="text-align:center">命令行</th></tr></thead><tbody><tr><td style="text-align:center">CHLD</td><td style="text-align:center">子进程终止的时候向Master进程发送（用于监控子进程）</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TERM,INT</td><td style="text-align:center">终止</td><td style="text-align:center">stop</td></tr><tr><td style="text-align:center">QUIT</td><td style="text-align:center">优雅的退出</td><td style="text-align:center">quit</td></tr><tr><td style="text-align:center">HUP</td><td style="text-align:center">重载</td><td style="text-align:center">reload</td></tr><tr><td style="text-align:center">USR1</td><td style="text-align:center">重新开始记录日志</td><td style="text-align:center">reopen</td></tr><tr><td style="text-align:center">USR2</td><td style="text-align:center">关闭旧Nginx主进程并启动新的</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">WINCH</td><td style="text-align:center">退出旧的主进程</td></tr></tbody></table></div><h3 id="Worker进程"><a href="#Worker进程" class="headerlink" title="Worker进程"></a>Worker进程</h3><div class="table-container"><table><thead><tr><th style="text-align:center">信号</th><th style="text-align:center">功能</th><th style="text-align:center">命令行</th></tr></thead><tbody><tr><td style="text-align:center">TERM,INT</td><td style="text-align:center">启动,终止</td><td style="text-align:center">stop</td></tr><tr><td style="text-align:center">QUIT</td><td style="text-align:center">优雅的退出</td><td style="text-align:center">quit</td></tr><tr><td style="text-align:center">USR1</td><td style="text-align:center">重新开始记录日志</td><td style="text-align:center">reopen</td></tr><tr><td style="text-align:center">WINCH</td><td style="text-align:center">退出旧的主进程</td></tr></tbody></table></div><p>使用<code>kill -signal PID</code>即可完成操作</p><h3 id="热升级流程"><a href="#热升级流程" class="headerlink" title="热升级流程"></a>热升级流程</h3><ul><li>将旧版本的Nginx替换，编译安装的话新程序直接编译到Nginx安装目录中</li><li><code>kill -USR2 旧主进程的PID</code>(旧的Nginx主进程将会把自己的进程文件改名为.oldbin)</li><li><code>kill -WINCH 旧主进程的PID</code>逐步关闭旧的worker</li><li><code>kill -QUIT 旧主进程的PID</code>关闭旧的master<br>备注：如果回滚向老进程发送<code>HUB</code>，向新进程发送<code>QUIT</code></li></ul><h2 id="Nginx基本架构及模块分类"><a href="#Nginx基本架构及模块分类" class="headerlink" title="Nginx基本架构及模块分类"></a>Nginx基本架构及模块分类</h2><p><img src="https://myblog-1254913510.file.myqcloud.com/u4cpq.png" style="zoom:50%;" /></p><h2 id="同步异步与阻塞非阻塞"><a href="#同步异步与阻塞非阻塞" class="headerlink" title="同步异步与阻塞非阻塞"></a>同步异步与阻塞非阻塞</h2><p>阻塞与非阻塞主要在讨论操作系统底层的实现效果</p><p>阻塞： 进程运行所需条件没准备好时 操作系统将进程sleep 直到有条件满足时唤醒</p><p>非阻塞：进程运行所需条件没准备好时 在时间片用完前不会被切换掉 进程处理后续的操作</p><p>同步与异步讨论的是业务逻辑的事情</p><p>同步：调用接口后<strong>需要</strong>等待接口处理完数据并相应进程才能继续执行</p><p>异步：调用接口后<strong>不需要</strong>等待数据处理完可以继续执行，后续数据准备好通过一定的方式获得，例如回调</p><p>例子：</p><p>以超市买东西付款为例。</p><p>同步阻塞：需要等收银员扫描完我的商品后才能付款 我才能干别的事情。再这之前我一直看着她。</p><p>同步非阻塞：你先扫描 我先去看看别的东西。过一会看一眼服务员扫了多少了 也就是轮询。</p><p>异步非阻塞： 我就在隔壁买个咖啡。扫完了你叫我一声。</p><p>异步阻塞 应该不存在吧。</p><h2 id="Linux的几个I-O模型"><a href="#Linux的几个I-O模型" class="headerlink" title="Linux的几个I/O模型"></a>Linux的几个I/O模型</h2><h2 id="Nginx用到的几个容器"><a href="#Nginx用到的几个容器" class="headerlink" title="Nginx用到的几个容器"></a>Nginx用到的几个容器</h2><p>进程间通信使用共享内存</p><p>数组 ngx<em>array_t<br>链表 ngx_list_t<br>队列 ngx_q_t<br>哈希表 ngx</em><br>红黑树<br>基数树 </p><p>未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github Action尝鲜-创建Hexo Deploy Action</title>
    <link href="/posts/47780/"/>
    <url>/posts/47780/</url>
    
    <content type="html"><![CDATA[<p>这几天弄好自己用的生成发布hexo博客用的workflow，感觉效果还不错，索性做成一个action发布一下，另外遇到一些问题也记录一下。</p><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><p>第一次使用alpine Docker不是很熟悉这个高度精简的系统</p><p>1、一些常用软件包的名字可能会变得不太一样，使用前在<a href="https://pkgs.alpinelinux.org/packages">https://pkgs.alpinelinux.org/packages</a>上查找一下 然后在Dockerfile里面<code>RUN apk add xxx</code>即可</p><p>2、注意GitHub action的运行环境是用<code>root</code>用户运行的，所以注意像添加<code>known_hosts</code>之类的要添加到<code>/root/.ssh/known_hosts</code>下面</p><p>3、npm的使用上局部安装的话使用npx hexo command</p><h2 id="体验地址"><a href="#体验地址" class="headerlink" title="体验地址"></a>体验地址</h2><p>GitHub Market<a href="https://github.com/marketplace/actions/hexo-github-action">https://github.com/marketplace/actions/hexo-github-action</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>GitHub-Action</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用shell脚本判断git状态</title>
    <link href="/posts/43978/"/>
    <url>/posts/43978/</url>
    
    <content type="html"><![CDATA[<p>​在终于无法忍受包含中文的链接带来的种种问题以后，我决定把固定连接的格式修改一下，为此使用了<code>hexo-abbrlink</code>这个插件来进行文章编号的生成。</p><p>​这个插件会在<code>hexo g</code>的时候生成文章编号并将编号存储在文章<code>abbrlink</code>字段里面，这就意味着在hexo g的过程中需要修改文章源文件才能将文章编号持久化存储起来。</p><p>​这个过程在本地运行自然是没什么问题，然而如果使用GitHub actions自动生成并发布的话，就意味着在执行<code>hexo g</code>之后需要将当前的修改<code>push</code>回源代码仓库才行，这个操作看上去没什么问题，我甚至也发现了一个现成的<a href="https://github.com/ad-m/github-push-action">github-push-action</a>用于将代码push回原仓库。</p><p>​但是在实际操作中我发现在文件没有任何文件发生更改时执行<code>git commit -m &quot;something&quot; -a</code>的返回值是<code>1</code>，而这会导致<code>GitHub-actions</code>判定该<code>step</code>执行状态为<code>fail</code>进而终止执行。</p><p>​于是我考虑使用简单的<code>shell</code>语句来判断文件是否有修改，进而执行相应操作，将判断文件状态的几种可能方案记录如下：</p><p>​1、<code>git diff --quiet --exit-code --cached</code>可以用于判断已经追踪的文件是否有更改</p><p>​2、<code>if [ -z &quot;$(git status --porcelain)&quot; ]</code>可以检查文件是否有修改</p><p>​3、<code>exit $( git status --porcelain | wc -l )</code>可以直接作为返回值判0</p><p>具体代码如下</p><pre><code class="hljs bash">remote_repo=<span class="hljs-string">&quot;https://<span class="hljs-variable">$&#123;GITHUB_ACTOR&#125;</span>:<span class="hljs-variable">$&#123;&#123;secrets.GITHUB_TOKEN&#125;</span>&#125;@github.com/<span class="hljs-variable">$&#123;GITHUB_REPOSITORY&#125;</span>.git&quot;</span><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-subst">$(git status --porcelain)</span>&quot;</span> ]<span class="hljs-keyword">then</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nothing to update.&quot;</span><span class="hljs-keyword">else</span>    git commit -m <span class="hljs-string">&quot;triggle by commit <span class="hljs-variable">$&#123;&#123; github.sha &#125;</span>&#125;. created by <span class="hljs-variable">$&#123;&#123; github.workflow &#125;</span>&#125;.&quot;</span> -a    git push <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;remote_repo&#125;</span>&quot;</span> HEAD:master<span class="hljs-keyword">fi</span></code></pre><p><strong>参考资料:</strong> </p><p><a href="https://www.itranslater.com/qa/details/2126861753253364736">https://www.itranslater.com/qa/details/2126861753253364736</a></p>]]></content>
    
    
    <categories>
      
      <category>shell脚本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub-Actions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更新固定链接格式</title>
    <link href="/posts/8279/"/>
    <url>/posts/8279/</url>
    
    <content type="html"><![CDATA[<p>订阅了我博客RSS的朋友（如果真的有的话）可能发现一下子多了很多更新，得和大家说声抱歉，这只是因为我刚刚更新了博客固定链接的格式给大家带来打扰实在抱歉。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈GPG</title>
    <link href="/posts/37452/"/>
    <url>/posts/37452/</url>
    
    <content type="html"><![CDATA[<p>​        写这个是因为前几天在配置好GitHub actions后勉强可以在网页上直接写东西了，上面一篇内容就是在网页写的，然而在发布之后查看commit记录的时候我发现通过网页提交的commit旁边会有一个<code>Verified</code>字样，点开以后会显示<code>This commit was created on GitHub.com and signed with a verified signature using GitHub’s key.</code> 感觉看上去挺有意思，于是尝试一下配置自己的GPG密钥，给commit记录签名。感觉网上的东西说的不是很让人明白，索性在这里再记录一下自己的体会。</p><p>​        下面的内容在macOS Catalina上进行。</p><h3 id="GPG简介"><a href="#GPG简介" class="headerlink" title="GPG简介"></a>GPG简介</h3><blockquote><p>1991年，程序员<a href="http://en.wikipedia.org/wiki/Phil_Zimmermann">Phil Zimmermann</a>为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个PGP的替代品，取名为GnuPG。这就是GPG的由来。 from <a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html">阮一峰的网络日志</a></p></blockquote><h3 id="GPG密钥生成及使用"><a href="#GPG密钥生成及使用" class="headerlink" title="GPG密钥生成及使用"></a>GPG密钥生成及使用</h3><p><strong>软件安装</strong></p><p>​        首先是安装，在macOS上面可以直接使用homebrew来进行，如果你还没有开始使用这个优秀的包管理工具，强烈推荐你<a href="https://brew.sh/">了解一下</a>，并开始使用。</p><p><code>brew install gnupg2 #有些教程提到一定要用gnupg2经过我的测试目前gnupg也已经指向gnupg2了是一样的</code> </p><p>​        另外建议安装<code>gpg-suite</code>这个管理工具，在配置git的时候会更加方便，不过这和本文无关。</p><p><strong>密钥生成</strong></p><p>​        输入<code>gpg --full-generate-key</code> 按照提示进行操作，注意如果你的语言设置为中文的话在输入保护密码的时候会出现乱码不过不影响操作，不理会即可。</p><p><strong>密钥管理</strong></p><p>​        在仔细查阅资料后我发现，在较早期的时候因为兼容性问题对于是否使用子密钥有一定争议，但是对于现在来说在日常使用时使用子密钥而不是主密钥进行加密签名等操作已经被认为是一种最佳实践，所以很有必要学习一下。</p><p>​        在默认情况下，只想上面操作时会生成一对主密钥（用于签名）和一对子密钥（用于加密），使用<code>gpg --list-secret-keys --keyid-format LONG</code>即可查看。</p><p>如果想要生成其他子密钥使用<code>gpg --edit-key [key-id]</code>即可进入编辑模式，下面简单罗列一些常用命令备查：</p><p>使用<code>addkey</code>即可添加新的子密钥</p><p><code>gpg -o path/to/somewhere --export-secret-keys [key-id]</code>导出私钥备份<br><code>gpg -o path/to/somewhere --export-secret-subkeys 71C861745213C7</code>导出私子密钥备份</p><p><code>~/.gnupg/openpgp-revocs.d/</code>吊销证书默认存储位置</p><p><code>gpg --delete-secret-keys [key-id]</code>删除私钥</p><p><code>gpg --import path/to/key</code>导入私钥</p><p>将吊销证书导入即可吊销本地</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><a href="https://nova.moe/openpgp-best-practices-key-configuration/">https://nova.moe/openpgp-best-practices-key-configuration/</a></p><h3 id="一些不错的资料"><a href="#一些不错的资料" class="headerlink" title="一些不错的资料"></a>一些不错的资料</h3><p>因为网络资料很齐全剩下的内容就不再详述了，参加下面几篇文章就好。</p><p><a href="https://emacsist.github.io/2019/01/01/gnupg2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/">GnuPG2使用指北</a></p><p><a href="https://blog.chaos.run/dreams/using-gpg/">如何使用 GPG 管理密钥</a></p><p><a href="https://mogeko.me/2019/068/">GPG 的正确使用姿势</a></p><p><a href="https://www.leadroyal.cn/?p=502">Q&amp;A</a></p><h3 id="关于git-commit签名"><a href="#关于git-commit签名" class="headerlink" title="关于git commit签名"></a>关于git commit签名</h3><p><a href="https://help.github.com/en/github/authenticating-to-github/managing-commit-signature-verification">gitHub文档</a></p><p><a href="https://mogeko.me/2019/065/">使用 GPG 签名你的 Git Commit</a></p><h3 id="我的GPG-Key"><a href="#我的GPG-Key" class="headerlink" title="我的GPG Key"></a>我的GPG Key</h3><p>最后附上我的<a href="https://blog.yrpang.com/GPG-key/">GPG Key</a></p>]]></content>
    
    
    <categories>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPG</tag>
      
      <tag>gitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-GitHub-Actions</title>
    <link href="/posts/55815/"/>
    <url>/posts/55815/</url>
    
    <content type="html"><![CDATA[<p>  我的博客是使用Hexo搭建的，一直面临着博客撰写不方便的问题，刚好GitHub推出了Actions功能，半期考刚刚结束，闲来无事索性尝一下借助这个工具来完成博客的自动生成部署工作，满足我网页写博客的需求。</p><h2 id="一些介绍-amp-准备："><a href="#一些介绍-amp-准备：" class="headerlink" title="一些介绍&amp;准备："></a>一些介绍&amp;准备：</h2><p>  目前GitHub Actions还没有正式发布所以需要注册一个Beta版本的体验资格，不过因为距离正式发布已经很近了，所以这步没有难度直接去官网注册即可。另外现在官方也提供了很多方便的<a href="https://github.com/actions">工具</a>帮助使用者更快速的实现自己想要的功能。</p><p>  另外附上官方文档参考<br>  <a href="https://help.github.com/en/github/automating-your-workflow-with-github-actions">https://help.github.com/en/github/automating-your-workflow-with-github-actions</a></p><h2 id="workflow："><a href="#workflow：" class="headerlink" title="workflow："></a>workflow：</h2><p>  创建<code>.github/workflow</code>目录然后在目录里放workflow文件就好了<br>  文件见 <a href="https://gist.github.com/yrpang/82a4a546c737d44cd58ca56595e3c335">https://gist.github.com/yrpang/82a4a546c737d44cd58ca56595e3c335</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub-Action</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django动态表单</title>
    <link href="/posts/4202/"/>
    <url>/posts/4202/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tests</span>(<span class="hljs-params">request</span>):</span>    field_dict=&#123;&#125;    question = models.Questions.objects.<span class="hljs-built_in">all</span>().order_by(<span class="hljs-string">&#x27;id&#x27;</span>)    <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> question:        field_dict[<span class="hljs-string">&#x27;question_%s&#x27;</span> %q.<span class="hljs-built_in">id</span>] = fields.CharField(                    required=<span class="hljs-literal">False</span>,                    label = q.title,                    widget = widgets.Textarea                )    MyAnswerForm = <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;MyAnswerForm&#x27;</span>, (Form,), field_dict)    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;GET&#x27;</span>:        ini = &#123;&#125;        <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> question:            ini[<span class="hljs-string">&#x27;question_%s&#x27;</span>%q.<span class="hljs-built_in">id</span>] = q.ans.first().answer        formset = MyAnswerForm(initial=ini)        <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;tests.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;formset&#x27;</span>:formset&#125;)    <span class="hljs-keyword">else</span>:        ans = MyAnswerForm(request.POST)        user = models.User.objects.get(<span class="hljs-built_in">id</span>=request.session.get(<span class="hljs-string">&#x27;user_id&#x27;</span>))        <span class="hljs-keyword">if</span> ans.is_valid():            ans = ans.cleaned_data                        <span class="hljs-keyword">for</span> key,v <span class="hljs-keyword">in</span> ans.items():                k,qid = key.rsplit(<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-number">1</span>)                <span class="hljs-keyword">try</span>:                    a=models.Answers.objects.get(question__id=qid, user=user)                    a.answer=v                    a.save()                <span class="hljs-keyword">except</span> models.Answers.DoesNotExist:                    q = models.objcets.get(<span class="hljs-built_in">id</span>=qid)                    models.objects.create(user=user, question=q, answer=v)        formset = MyAnswerForm(request.POST)        <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;tests.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;formset&#x27;</span>:formset&#125;)</code></pre><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/tests/&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;answer&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span></span><span class="xml">        </span><span class="hljs-template-variable">&#123;&#123; formset.management_form &#125;&#125;</span><span class="xml">        </span><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">csrf_token</span></span> %&#125;</span><span class="xml">        </span><span class="hljs-template-variable">&#123;&#123;formset&#125;&#125;</span><span class="xml">        </span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>保存<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span></code></pre><p><strong>参考资料</strong><br><a href="https://www.cnblogs.com/ugfly/p/8215384.html">https://www.cnblogs.com/ugfly/p/8215384.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Django</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django获取小程序码并返回</title>
    <link href="/posts/58401/"/>
    <url>/posts/58401/</url>
    
    <content type="html"><![CDATA[<p>今天实现小程序码获取和返回的一些功能遇到了一些问题，记录一下。</p><h2 id="一、二维码的获取"><a href="#一、二维码的获取" class="headerlink" title="一、二维码的获取"></a>一、二维码的获取</h2><p>二维码的获取调用微信提供的<code>wxacode.getUnlimited</code>接口即可，这里注意微信的返回值有两种。如果获取成功则返回图片的二进制数据流，如果获取失败会返回<code>json</code>格式的错误代码。</p><p>另外注意请求参数需要使用<code>json.dumps()</code>封装为<code>json</code>格式，另外请求头要添加<code>Application/json</code>，并且附带的参数名称全为小写，否则的话会返回<code>invalid format</code>错误。</p><h2 id="二、二维码处理并返回"><a href="#二、二维码处理并返回" class="headerlink" title="二、二维码处理并返回"></a>二、二维码处理并返回</h2><p>因为微信接口返回的为<code>Buffer</code>所以这里有两种思路：</p><p>1、将文件流base64编码返回给小程序，小程序直接解吗显示，代码如下</p><pre><code class="hljs js">onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;  <span class="hljs-built_in">this</span>.setData(&#123;    src: <span class="hljs-string">&#x27;data:image/png;base64,&#x27;</span> + DATA_FROM_BACKEND  &#125;)&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#123;&#123;src&#125;&#125;&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;image&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> requests<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getQR</span>(<span class="hljs-params">request</span>):</span>  url = <span class="hljs-string">&quot;https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=&quot;</span>+<span class="hljs-built_in">str</span>(access_token)  headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;  <span class="hljs-comment"># 注意添加这个请求头</span>data = &#123;<span class="hljs-string">&#x27;scene&#x27;</span>:<span class="hljs-string">&#x27;team_id=&#x27;</span>+<span class="hljs-built_in">str</span>(team_id),  <span class="hljs-string">&#x27;is_hyaline&#x27;</span>: <span class="hljs-literal">True</span>&#125;  r = requests.post(url, data=json.dumps(data), headers=headers)  <span class="hljs-keyword">return</span> HttpResponse(base64.b64encode(r.content))</code></pre><p>2、将二进制存储为图片并返回url，代码如下：</p><pre><code class="hljs js">onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>    that.setData(&#123;      <span class="hljs-string">&quot;src&quot;</span>: app.globalData.server_url+res.data.src    &#125;)&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#123;&#123;src&#125;&#125;&#x27;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;image&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></code></pre><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getQR</span>(<span class="hljs-params">request</span>):</span>      url = <span class="hljs-string">&quot;https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=&quot;</span>+<span class="hljs-built_in">str</span>(access_token)    headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;    data = &#123;<span class="hljs-string">&#x27;scene&#x27;</span>:<span class="hljs-string">&#x27;team_id=&#x27;</span>+<span class="hljs-built_in">str</span>(team_id),  <span class="hljs-string">&#x27;is_hyaline&#x27;</span>: <span class="hljs-literal">True</span>&#125;        r = requests.post(url, data=json.dumps(data), headers=headers)    i = BytesIO(r.content)    roiImg = Image.<span class="hljs-built_in">open</span>(i)    print(<span class="hljs-built_in">type</span>(roiImg))    savepath = os.path.join(os.getcwd() ,<span class="hljs-string">&#x27;media/&#x27;</span>)    name = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time())) + <span class="hljs-string">r&#x27;.png&#x27;</span>    roiImg.save(<span class="hljs-built_in">str</span>(savepath)+name, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;PNG&#x27;</span>)    <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;src&#x27;</span>: <span class="hljs-string">&#x27;/media/%s&#x27;</span>%(name)&#125;)</code></pre><p>之后设置一下nginx就ok</p><p><strong>参考资料：</strong></p><p>1 <a href="https://www.jianshu.com/p/28e6e090966a">https://www.jianshu.com/p/28e6e090966a</a></p><p>2 <a href="https://blog.csdn.net/uikoo9/article/details/86088028">https://blog.csdn.net/uikoo9/article/details/86088028</a></p><p>3 <a href="https://blog.csdn.net/qq_32446743/article/details/87780821">https://blog.csdn.net/qq_32446743/article/details/87780821</a></p><p>4 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctf-web&amp;misc学习小结</title>
    <link href="/posts/27393/"/>
    <url>/posts/27393/</url>
    
    <content type="html"><![CDATA[<p>参加“信息安全实验班”选拔前整理的一些东西。</p><h2 id="一、vim查看二进制"><a href="#一、vim查看二进制" class="headerlink" title="一、vim查看二进制"></a>一、vim查看二进制</h2><pre><code class="hljs bash">vim -b <span class="hljs-string">&quot;file_name&quot;</span>%!xxd%!xxd -r</code></pre><h2 id="二、文件包含"><a href="#二、文件包含" class="headerlink" title="二、文件包含"></a>二、文件包含</h2><p><code>eval(&quot;var_dump($a);&quot;);</code>函数可以将变量内容当作代码执行</p><p><code>get_file_contents(&#39;./path&#39;)</code>可以获取文件内容</p><p><code>&lt;script language=php&gt;system(&quot;ls&quot;)&lt;/script&gt;</code></p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>如果进行了正则匹配的话可以使用<code>GLOBALS</code>显示所有变量</p><h2 id="三、unicode编码解码"><a href="#三、unicode编码解码" class="headerlink" title="三、unicode编码解码"></a>三、unicode编码解码</h2><p>使用<code>document.write()</code>可以直接显示</p><h2 id="四、弱类型"><a href="#四、弱类型" class="headerlink" title="四、弱类型"></a>四、弱类型</h2><p><code>is_numeric()</code>用来判断内容是不是数字</p><p><code>if($num==1)</code>会进行类型转换所以<code>1a == 1</code></p><h2 id="五、域名解析"><a href="#五、域名解析" class="headerlink" title="五、域名解析"></a>五、域名解析</h2><p><code>修改请求头的host字段</code></p><h2 id="六、JSFUCK"><a href="#六、JSFUCK" class="headerlink" title="六、JSFUCK"></a>六、JSFUCK</h2><p>是一种深奥的JavaScript 编程风格，直接运行</p><h2 id="七、注意抓包观察返回的头"><a href="#七、注意抓包观察返回的头" class="headerlink" title="七、注意抓包观察返回的头"></a>七、注意抓包观察返回的头</h2><h2 id="八、本地访问"><a href="#八、本地访问" class="headerlink" title="八、本地访问"></a>八、本地访问</h2><p><code>x-forwarded-for:127.0.0.1</code>字段表示访问的真实ip</p><h2 id="九、你从哪里来"><a href="#九、你从哪里来" class="headerlink" title="九、你从哪里来"></a>九、你从哪里来</h2><p><code>Referer</code>可以指示</p><p><em>注意：</em> <code>Referer: https://www.google.com</code>没有结尾</p><h2 id="十、unescape可以用来解码"><a href="#十、unescape可以用来解码" class="headerlink" title="十、unescape可以用来解码"></a>十、unescape可以用来解码</h2><h2 id="十一、php一些内容"><a href="#十一、php一些内容" class="headerlink" title="十一、php一些内容"></a>十一、php一些内容</h2><p>显示文件内容<code>php://filter/read=convert.base64-encode/resource=./index.php</code></p><p><code>php://input</code>是POST data的输入流可以放进<code>get_file_contents()</code>函数读取</p><p><code>NULL</code>的序列化是<code>s:0:&quot;&quot;;</code></p><p>;的转义是<code>%3B</code></p><h2 id="十二、cookie模拟元素点击"><a href="#十二、cookie模拟元素点击" class="headerlink" title="十二、cookie模拟元素点击"></a>十二、cookie模拟元素点击</h2><p><code>$(&quot;#cookie&quot;).mouseup()</code></p><h2 id="十三、各种绕过"><a href="#十三、各种绕过" class="headerlink" title="十三、各种绕过"></a>十三、各种绕过</h2><p>MD5弱类型 <code>s878926199a</code>和<code>s155964671a</code></p><p>md5绕过方法：<br>1.可以通过一些特殊的字符串，<br>2.数组绕过。如果v1 v2是两个数组，md5函数不能获取到值，可以绕过。</p><p>strcmp绕过：<br>将v3构造成数组。<br>strcmp(array,string)=null=0</p><p>strcmp() 函数比较两个字符串，且对大小写敏感。</p><p>0 - 如果两个字符串相等</p><p>&lt;0 - 如果 string1 小于 string2<br>0 - 如果 string1 大于 string2</p><p>数组可以绕过<code>sha1()</code></p><p>解题方法：</p><p>GET请求： ?flag=&amp;gift=</p><h2 id="十四、遇到自动跳转的"><a href="#十四、遇到自动跳转的" class="headerlink" title="十四、遇到自动跳转的"></a>十四、遇到自动跳转的</h2><p><code>curl url</code></p><h2 id="十五、注意robots-txt可能会有收获"><a href="#十五、注意robots-txt可能会有收获" class="headerlink" title="十五、注意robots.txt可能会有收获"></a>十五、注意<code>robots.txt</code>可能会有收获</h2><h2 id="十六、求getshell"><a href="#十六、求getshell" class="headerlink" title="十六、求getshell"></a>十六、求getshell</h2><p>修改<code>Content-Type字段 multipart/form-data任意一个字母为大写</code></p><p><em>拓展名</em> 尝试 <code>php2, php3, php4, php5，phps, pht, phtm, phtml</code></p><h2 id="十七、Wifi密码破解"><a href="#十七、Wifi密码破解" class="headerlink" title="十七、Wifi密码破解"></a>十七、Wifi密码破解</h2><p><code>crunch 11 11 -t 1391040%%%% &gt;&gt; lib.txt</code>生成字典</p><h2 id="十八、zip伪加密"><a href="#十八、zip伪加密" class="headerlink" title="十八、zip伪加密"></a>十八、zip伪加密</h2><p>50 4B 03 04：这是头文件标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密）</p><p>50 4B 01 02：目录中文件文件头标记(0x02014b50)<br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）</p><h2 id="十九、隐写"><a href="#十九、隐写" class="headerlink" title="十九、隐写"></a>十九、隐写</h2><p>工具<code>binwalk fcrackzip formost file</code></p><p><code>fcrackzip -b -l 3-3 -c1 -v flag.zip</code></p><p>Zip 50后面是开始</p><p>png的第二行是高和宽</p><p>栅栏密码 <a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">https://www.qqxiuzi.cn/bianma/zhalanmima.php</a></p><p> 16进制 <a href="https://www.bejson.com/convert/ox2str/">https://www.bejson.com/convert/ox2str/</a></p><p>编码解吗大全 <a href="https://blog.csdn.net/pdsu161530247/article/details/75667218">https://blog.csdn.net/pdsu161530247/article/details/75667218</a></p><h2 id="附、杂记"><a href="#附、杂记" class="headerlink" title="附、杂记"></a>附、杂记</h2><p>成绩出来了，成绩+机试排名22，这些天在反复纠结是否应该抓住这个机会，突然想明白了一个道理，觉得还是应该顺遂本心，向着自己的兴趣“自然语言处理”的方向努力，不该为了可能有所增加的保研机会就放弃自己的优势和积淀。<br>相信不管在哪里不去努力都是不行的，希望自己能够顺遂本心，在自己选择的方向上努力前行。<br>写在这里，记录一下，希望自己的选择是正确的。<br>2019.7.6 面试前夜</p><p><strong>参考资料：</strong></p><p><a href="https://giraff3.cn/2018/08/13/Bugku%E9%A2%98%E8%A7%A3(WEB)/">https://giraff3.cn/2018/08/13/Bugku%E9%A2%98%E8%A7%A3(WEB)/</a></p><p><a href="http://www.she1don.cn/index.php/archives/23.html">http://www.she1don.cn/index.php/archives/23.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[周报]2019年第20周</title>
    <link href="/posts/9864/"/>
    <url>/posts/9864/</url>
    
    <content type="html"><![CDATA[<p>从本周开始坚持每周写周报汇总学习生活和coding的情况，并展望未来。</p><h2 id="总结-amp-开篇："><a href="#总结-amp-开篇：" class="headerlink" title="总结&amp;开篇："></a>总结&amp;开篇：</h2><p>期中考试很差，总结过去的半个学期自己过得太浪了，什么都是蜻蜓点水，哪项也没有静下心来深入，接下来好好调整一下。</p><p>制定接下来定一周的小目标：</p><ul><li>完成手上的微信小程序项目</li><li>完成线性代数的复习回顾</li><li>完成波动光学部分的回顾整理</li><li>高数部分跟上进度</li><li>MOOC</li><li>体育打卡</li><li>坚持写周报</li></ul>]]></content>
    
    
    <categories>
      
      <category>周报</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tensoflow-logistic-regression</title>
    <link href="/posts/20414/"/>
    <url>/posts/20414/</url>
    
    <content type="html"><![CDATA[<p>之前数模参赛时遇到的一个问题，当时因为比赛的原因不方便马上发，现在发出来。</p><p>在本次数学建模中涉及到了<strong>logistic-regression</strong>模型的应用，简单记录一下<code>Tensorflow</code>的实现。</p><h2 id="1、环境"><a href="#1、环境" class="headerlink" title="1、环境"></a>1、环境</h2><p>我比较偷懒，直接使用了<code>Google Cloud Platform</code>免去了配置<code>Tensorflow</code>环境的麻烦。</p><h2 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h2><pre><code class="hljs python3">import pandas as pd                # 用于读取数据文件import tensorflow as tfimport matplotlib.pyplot as plt    # 用于画图import numpy as npdf &#x3D; pd.read_csv(&quot;input.csv&quot;, header&#x3D;None)train_data &#x3D; df.valuesprint(train_data)train_X &#x3D; train_data[:, :-1]train_y &#x3D; train_data[:, -1:]feature_num &#x3D; len(train_X[0])sample_num &#x3D; len(train_X)print(&quot;Size of train_X: &#123;&#125;x&#123;&#125;&quot;.format(sample_num, feature_num))print(&quot;Size of train_y: &#123;&#125;x&#123;&#125;&quot;.format(len(train_y), len(train_y[0])))X &#x3D; tf.placeholder(tf.float32)y &#x3D; tf.placeholder(tf.float32)W &#x3D; tf.Variable(tf.zeros([feature_num, 1]))b &#x3D; tf.Variable([-.9])db &#x3D; tf.matmul(X, tf.reshape(W, [-1, 1])) + bhyp &#x3D; tf.sigmoid(db)cost0 &#x3D; y * tf.log(hyp)cost1 &#x3D; (1 - y) * tf.log(1 - hyp)cost &#x3D; (cost0 + cost1) &#x2F; -sample_numloss &#x3D; tf.reduce_sum(cost)optimizer &#x3D; tf.train.GradientDescentOptimizer(0.001)train &#x3D; optimizer.minimize(loss)init &#x3D; tf.global_variables_initializer()sess &#x3D; tf.Session()sess.run(init)feed_dict &#x3D; &#123;X: train_X, y: train_y&#125;for step in range(1000000):    sess.run(train, &#123;X: train_X, y: train_y&#125;)    if step % 10000 &#x3D;&#x3D; 0:        print(step, sess.run(W).flatten(), sess.run(b).flatten())# 绘图w &#x3D; [0.7672361 , -0.276697 , -0.19542742]b &#x3D; 0.09650069from mpl_toolkits.mplot3d import Axes3Dx1 &#x3D; train_data[:, 0]x2 &#x3D; train_data[:, 1]x3 &#x3D; train_data[:, 2]y &#x3D; train_data[:, -1:]fig&#x3D;plt.figure()ax&#x3D;Axes3D(fig)for x1p, x2p, x3p, yp in zip(x1, x2, x3, y):    if yp &#x3D;&#x3D; 0:        ax.scatter(x1p, x2p, x3p, c&#x3D;&#39;r&#39;)    else:        ax.scatter(x1p, x2p, x3p, c&#x3D;&#39;g&#39;)ax.set_zlabel(&#39;Z&#39;)  # 坐标轴ax.set_ylabel(&#39;Y&#39;)ax.set_xlabel(&#39;X&#39;)a &#x3D; 0.7672361b &#x3D; -0.276697 c &#x3D; -0.19542742d &#x3D; 0.09650069x1 &#x3D; np.linspace(-1,1,10)y1 &#x3D; np.linspace(-1,1,10)X,Y &#x3D; np.meshgrid(x1,y1)Z &#x3D; (d - a*X - b*Y) &#x2F; cfig &#x3D; plt.figure()ax &#x3D; fig.gca(projection&#x3D;&#39;3d&#39;)surf &#x3D; ax.plot_surface(X, Y, Z)</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><pre><code class="hljs python3"># Result# 0 [ 0.7707945  -0.27244025 -0.19312732] [0.08507074]# 10000 [ 0.77019846 -0.2730363  -0.19343074] [0.08675246]# 20000 [ 0.76964736 -0.27363235 -0.19366762] [0.08829048]# 30000 [ 0.7692501  -0.27412957 -0.19393419] [0.08960892]# 40000 [ 0.7689034  -0.27445695 -0.19417214] [0.09070877]# 50000 [ 0.7686214  -0.27475497 -0.19436422] [0.09161869]# 60000 [ 0.7683936  -0.275053   -0.19451982] [0.09238537]# 70000 [ 0.7682283  -0.27535102 -0.19466883] [0.09303201]# 80000 [ 0.76810503 -0.27564904 -0.19481784] [0.09360377]# 90000 [ 0.76798075 -0.27594706 -0.19491854] [0.09411547]# 100000 [ 0.7678499  -0.2761182  -0.19500598] [0.09455331]# 110000 [ 0.76773375 -0.27622774 -0.19508578] [0.09492187]# 120000 [ 0.7676398  -0.27631634 -0.19515029] [0.0952199]# 130000 [ 0.7675626  -0.27638906 -0.19520319] [0.09546462]# 140000 [ 0.7674922  -0.27645552 -0.19525155] [0.09568814]# 150000 [ 0.76744366 -0.2765014  -0.19528496] [0.09584232]# 160000 [ 0.7673967  -0.27654564 -0.19531724] [0.09599134]# 170000 [ 0.76735574 -0.27658433 -0.19534537] [0.09612132]# 180000 [ 0.76733226 -0.2766065  -0.19536147] [0.09619582]# 190000 [ 0.7673087  -0.27662855 -0.1953776 ] [0.09627033]# 200000 [ 0.7672852  -0.27665073 -0.1953937 ] [0.09634484]# 210000 [ 0.7672618  -0.2766729  -0.19540988] [0.09641934]# 220000 [ 0.7672383  -0.2766951  -0.19542597] [0.09649385]# 230000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 240000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 250000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 260000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 270000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 280000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 290000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 300000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 310000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 320000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 330000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 340000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 350000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 360000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]# 370000 [ 0.7672361  -0.276697   -0.19542742] [0.09650069]</code></pre><p><strong>参考资料：</strong><br><a href="https://segmentfault.com/a/1190000009954640">https://segmentfault.com/a/1190000009954640</a><br><a href="http://bbs.bugcode.cn/t/20913">http://bbs.bugcode.cn/t/20913</a></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问网页的过程究竟发什么了什么</title>
    <link href="/posts/43826/"/>
    <url>/posts/43826/</url>
    
    <content type="html"><![CDATA[<h1 id="DNS查询得到IP"><a href="#DNS查询得到IP" class="headerlink" title="DNS查询得到IP"></a>DNS查询得到IP</h1><p>首先检查浏览器缓存 —&gt; 检查本机缓存 —&gt; 使用host —&gt; 路由器缓存 —&gt; DNS服务器递归查询</p><p>刷新Chrome缓存<code>chrome://net-internals/#dns</code></p><p>修改host会导致本机缓存被刷新，而浏览器缓存不刷新。</p><p><strong>清理本地缓存:</strong> <code>sudo dscacheutil -flushcache</code></p><h1 id="TCP-IP请求"><a href="#TCP-IP请求" class="headerlink" title="TCP/IP请求"></a>TCP/IP请求</h1><p>http的本质就是 tcp/ip请求</p><h2 id="连接过程：三次握手四次挥手"><a href="#连接过程：三次握手四次挥手" class="headerlink" title="连接过程：三次握手四次挥手"></a>连接过程：三次握手四次挥手</h2><h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><p>客户端：hello，你是server么？</p><p>服务端：hello，我是server，你是client么</p><p>客户端：yes，我是client</p><h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><p>主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</p><p>被动方：收到通道关闭的信息</p><p>被动方：那我也告诉你，我这边向你的主动通道也关闭了</p><p>主动方：最后收到数据，之后双方无法通信</p><h1 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h1><p>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。服务端的接收就是反过来的步骤。</p><p>五层因特尔协议栈其实就是：<br>1.应用层(dns,http) DNS解析成IP并发送http请求<br>2.传输层(tcp,udp) 建立tcp连接（三次握手）<br>3.网络层(IP,ARP) IP寻址<br>4.数据链路层(PPP) 封装成帧<br>5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</p><p>其实也有一个完整的OSI七层框架:<br>表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等<br>会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</p><h1 id="服务器接收到请求到对应后台接收到请求"><a href="#服务器接收到请求到对应后台接收到请求" class="headerlink" title="服务器接收到请求到对应后台接收到请求"></a>服务器接收到请求到对应后台接收到请求</h1><h2 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h2><p>1、浏览器组装好Request发送给WEB服务器<br>2、Nginx接受到Request之后根据请求资源类型进行分类,如果请求静态资源,Nginx会检索静态资源,并直接返回,如果是请求动态资源,会交给应用服务器.当然这其中会有请求缓冲,负载均衡等步骤.<br>3、实现了wsgi网管接口的应用服务器接收到http请求后,利用Werkzeng等网络编程工具实现的python程序(flask框架等)会根据request内容生成Response并返回给Nginx<br>4、Nginx缓冲Response,并将其返回给浏览器</p><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2><p>Nginx Apache 之类的叫做服务器软件，顾名思义，这是一个软件，用于运行web 服务的软件。也常被称作web服务器， HTTP服务器，其作用是用来处理HTTP协议的，且只能处理静态内容。也就是把服务器文件系统中的每一个资源对照成URI，然后通过HTTP协议把这些已经存在的资源传给发起HTTP请求的客户端。<br>他将动态资源交给应用服务器处理，静态资源则由web服务器直接返回浏览器，这样就减轻了应用服务器压力。</p><h2 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h2><p>仅仅响应静态内容是不够的，人们还需要动态的处理内容，返回动态的信息给客户端。 这就用到了服务器脚本。人们为了统一服务器脚本和web服务器之间的信息交互方式，提出了CGI，统一化标准。<br>WSGI规定了web服务器与web应用程序之间的标准接口，以确保web应用程序在不同的web服务器之间具有可移植性，在python web开发中，主流的选择是Gunicorn，uWSGI等实现WSGI的容器。</p><h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p>web服务器负责处理HTTP协议，应用服务器既可以处理HTTP协议，也能处理其他协议。<br>web服务器处理静态页面内容，动态内容通过WSGI接口交给应用服务器来处理。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。</p><h2 id="一些协议中间件对比"><a href="#一些协议中间件对比" class="headerlink" title="一些协议中间件对比"></a>一些协议中间件对比</h2><p>WSGI:Python Web Server Gateway Interface python 定义的web服务器与web应用程序之间的简单而通用的接口<br>Werkzeng: Werkzeug是Python基于WSGI协议写的函数库，它的应用很广泛<br>flask: 基于Werkzeng实现的轻量级web框架<br>Gunicorn: wsgi容器,可以用Gunicorn跑用flask等Werkzeng框架实现的程序,这样就实现了一个应用服务器</p><h1 id="解析页面流程"><a href="#解析页面流程" class="headerlink" title="解析页面流程"></a>解析页面流程</h1><p>解析HTML，构建DOM树</p><p>解析CSS，生成CSS规则树</p><p>合并DOM树和CSS规则，生成render树</p><p>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</p><p>绘制render树（paint），绘制页面像素信息</p><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</p><p><strong>参考资料:</strong><br><a href="https://www.jianshu.com/p/b5f58e5bed15">https://www.jianshu.com/p/b5f58e5bed15</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651553818&amp;idx=1&amp;sn=3ce840113d28ee2b2cafe4c7fc48ef91&amp;chksm=802557dbb752decd2118e3ad7a3ea803a0c41c6594f539fc54830dae9bbc2242b2fc03e7fb1c&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651553818&amp;idx=1&amp;sn=3ce840113d28ee2b2cafe4c7fc48ef91&amp;chksm=802557dbb752decd2118e3ad7a3ea803a0c41c6594f539fc54830dae9bbc2242b2fc03e7fb1c&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uwsgi</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云 gaierror: Temporary failure in name resolution错误解决</title>
    <link href="/posts/25327/"/>
    <url>/posts/25327/</url>
    
    <content type="html"><![CDATA[<p>今天中午<code>看图猜话</code>小程序的demo刚上线，告警群里就开始没完没了的报告脚本错误（此处略去心中一万句mmp…</p><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>看了一下<code>uwsgi.log</code>发现如下错误没有规律的间歇性出现</p><pre><code class="hljs shell">Internal Server Error: /Traceback (most recent call last):  File &quot;/usr/local/lib/python3.7/site-packages/urllib3/connection.py&quot;, line 159, in _new_conn    (self._dns_host, self.port), self.timeout, **extra_kw)  File &quot;/usr/local/lib/python3.7/site-packages/urllib3/util/connection.py&quot;, line 57, in create_connection    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):  File &quot;/usr/local/lib/python3.7/socket.py&quot;, line 748, in getaddrinfo    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):socket.gaierror: [Errno -3] Temporary failure in name resolutionDuring handling of the above exception, another exception occurred:Traceback (most recent call last):  File &quot;/usr/local/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 600, in urlopen    chunked=chunked)  File &quot;/usr/local/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 343, in _make_request    self._validate_conn(conn)  File &quot;/usr/local/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 839, in _validate_conn    conn.connect()  File &quot;/usr/local/lib/python3.7/site-packages/urllib3/connection.py&quot;, line 301, in connect    conn = self._new_conn()  File &quot;/usr/local/lib/python3.7/site-packages/urllib3/connection.py&quot;, line 168, in _new_conn    self, &quot;Failed to establish a new connection: %s&quot; % e)urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.VerifiedHTTPSConnection object at 0x7f201d4460b8&gt;: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution................</code></pre><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p><code>Temporary failure in name resolution</code>这句话看上去是在说<code>DNS</code>解析有问题，百度了一下发现有人在使用腾讯云时遇到类似错误，参照他的解决方案，问题解决，具体操作如下：</p><p><code>sudo vi /etc/resolv.conf</code>， 发现里面只有一条 nameserver 127.0.0.53<br>然而 <code>/etc/resolvconf/resolv.conf.d/base</code> 里面有俩条记录，手动把这俩条记录加到 <code>/etc/resolv.conf</code> 就正常了。</p><p>目前问题暂时解决。</p><p><strong>参考资料:</strong><br><a href="https://low.bi/p/azd1wpBgZJl">https://low.bi/p/azd1wpBgZJl</a><br><a href="https://www.cnblogs.com/ruigu/p/8603247.html">https://www.cnblogs.com/ruigu/p/8603247.html</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>uwsgi</tag>
      
      <tag>腾讯云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Miniflux搭建-Nginx反代-LetsEncrypt证书配置</title>
    <link href="/posts/22683/"/>
    <url>/posts/22683/</url>
    
    <content type="html"><![CDATA[<h2 id="Miniflux搭建"><a href="#Miniflux搭建" class="headerlink" title="Miniflux搭建:"></a>Miniflux搭建:</h2><p>这部分没啥说的，官方文档很清晰，照着做就完了。</p><h2 id="配置Nginx反代："><a href="#配置Nginx反代：" class="headerlink" title="配置Nginx反代："></a>配置Nginx反代：</h2><pre><code class="hljs ngin">server&#123;    listen [::]:443 ssl ipv6only&#x3D;on; # managed by Certbot    listen 443 ssl; # managed by Certbot    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;rss.lnception.cn&#x2F;fullchain.pem; # managed by Certbot    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;rss.lnception.cn&#x2F;privkey.pem; # managed by Certbot    include &#x2F;etc&#x2F;letsencrypt&#x2F;options-ssl-nginx.conf; # managed by Certbot    ssl_dhparam &#x2F;etc&#x2F;letsencrypt&#x2F;ssl-dhparams.pem; # managed by Certbot    server_name rss.lnception.cn;    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;;        proxy_set_header Host $host;        proxy_redirect off;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    &#125;&#125;server &#123;    if ($host &#x3D; rss.lnception.cn) &#123;        return 301 https:&#x2F;&#x2F;$host$request_uri;    &#125; # managed by Certbot        listen 80 ;        listen [::]:80 ;    server_name rss.yrpang.com;    return 404; # managed by Certbot&#125;</code></pre><h2 id="LetsEncrypt证书配置"><a href="#LetsEncrypt证书配置" class="headerlink" title="LetsEncrypt证书配置"></a>LetsEncrypt证书配置</h2><p><code>https://certbot.eff.org/lets-encrypt/ubuntubionic-nginx</code></p><p><strong>参考资料：</strong><br><a href="https://docs.miniflux.app/en/2.0.7/configuration.html">https://docs.miniflux.app/en/2.0.7/configuration.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>postgresql安装与使用</title>
    <link href="/posts/48821/"/>
    <url>/posts/48821/</url>
    
    <content type="html"><![CDATA[<p>今天在使用<code>Miniflux</code>时需要用到<code>postgresql</code>数据库，折腾了好长时间才搞明白这个东西怎么用。<br><del>开篇之前我要先吐槽<code>postgresql</code>好难用啊，太他妈难用了啊啊啊。</del><br>3.10 更正：刚看到python社区发的报告，这数据库使用率第一？？这样看来大概是我坑爹emmm……不敢吐槽了，赶紧好好看看咋用。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>Ubuntu 18.4LTS<br>postgresql 最新版</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>1、安装：<br>首先安装使用<code>sudo apt install postgresql</code><br>安装之后会出现<br><pre><code class="hljs bash">Success. You can now start the database server using:    /usr/lib/postgresql/10/bin/pg_ctl -D /var/lib/postgresql/10/main -l logfile startVer Cluster Port Status Owner    Data directory              Log file10  main    5432 down   postgres /var/lib/postgresql/10/main /var/<span class="hljs-built_in">log</span>/postgresql/postgresql-10-main.log</code></pre><br>此处注意<code>postgresql</code>只能使用非特权用户运行，管理之类的也只能使用<code>postgres</code>用户操作，所以接下来<code>su - postgres</code></p><p>切换以后上面提示里面的命令运行后会报错说配置文件不存在</p><p>接下来可以手动指定<code>/etc/postgresql</code>目录下面的配置文件，也可以重新初始化数据库使用<code>/usr/lib/postgresql/10/bin/pg_ctl initdb -D /var/lib/postgresql/11</code>重新初始化一个数据库这样子配置文件就在这个文件夹</p><p>可以直接使用<code>/usr/lib/postgresql/10/bin/pg_ctl -D /var/lib/postgresql/11 -l logfile start</code>启动</p><p>到此安装完毕。</p><p>2、卸载：<br>我们正常思路可能是用<code>sudo apt remove postgresql</code>然而事实上并不行</p><p>重新安装后会发现配置文件还在没法重新初始化</p><p>这里搬运一下完全卸载方法:<br><pre><code class="hljs bash">1.apt-get --purge remove postgresql\* //删除软件本体2.rm -r /etc/postgresql/ //删除配置文件3.rm -r /etc/postgresql-common/ //同上4.rm -r /var/lib/postgresql/ //同上5.userdel -r postgres //删除软件自动创建的用户6.groupdel postgres //删除其用户组</code></pre></p><p><strong>参考资料：</strong><br><a href="http://www.u3coding.com/2017/08/27/%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93postgresql%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E6%80%BB%E7%BB%93/">http://www.u3coding.com/2017/08/27/%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93postgresql%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E6%80%BB%E7%BB%93/</a><br><a href="https://github.com/yandex-qatools/postgresql-embedded/issues/74">https://github.com/yandex-qatools/postgresql-embedded/issues/74</a><br><a href="https://blog.csdn.net/dyx1024/article/details/6594851">https://blog.csdn.net/dyx1024/article/details/6594851</a><br><a href="https://juejin.im/post/5b2cb169e51d4558cc35bd7c">https://juejin.im/post/5b2cb169e51d4558cc35bd7c</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户ID生成算法总结</title>
    <link href="/posts/7566/"/>
    <url>/posts/7566/</url>
    
    <content type="html"><![CDATA[<p><strong>参考资料</strong> </p><p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">https://tech.meituan.com/2017/04/21/mt-leaf.html</a></p><p><a href="https://juejin.im/post/5b3a23746fb9a024e15cad79">https://juejin.im/post/5b3a23746fb9a024e15cad79</a></p><p><a href="https://www.jianshu.com/p/9d7ebe37215e">https://www.jianshu.com/p/9d7ebe37215e</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>.gitignore生效问题</title>
    <link href="/posts/54247/"/>
    <url>/posts/54247/</url>
    
    <content type="html"><![CDATA[<p>修改<code>.gitignore</code>会出现不生效的情况，清除缓存即可</p><pre><code class="hljs shell">git rm -r --cached .  #清除缓存git add . #重新trace filegit commit -m &quot;update .gitignore&quot; #提交和注释git push origin master #可选，如果需要同步到remote上的话</code></pre>]]></content>
    
    
    <categories>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-改变列表内元素属性</title>
    <link href="/posts/39954/"/>
    <url>/posts/39954/</url>
    
    <content type="html"><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>微信小程序渲染一个列表，列表中有包含按钮。</p><p>按钮状态有由列表特定<code>item</code>的一个属性决定。</p><p>需求是 点击按钮，触发操作，同时改变其状态。</p><p>尝试了n次才找到办法，记录一下。</p><pre><code class="hljs javascript">Page(&#123;    data: &#123;    match_id: <span class="hljs-number">0</span>,    teams: [],  &#125;,      follow: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-keyword">var</span> that=<span class="hljs-built_in">this</span>    <span class="hljs-keyword">var</span> team_id = e.currentTarget.dataset.team_id    <span class="hljs-keyword">var</span> num = e.target.id    wx.request(&#123;      url: app.globalData.server_url + <span class="hljs-string">&#x27;team/follow/&#x27;</span>,      method: <span class="hljs-string">&quot;POST&quot;</span>,      data:&#123;        openid: app.globalData.openid,        teamid: team_id      &#125;,      <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span>&#123;        that.setData(&#123;          [<span class="hljs-string">&#x27;teams[&#x27;</span> + num + <span class="hljs-string">&#x27;].mark&#x27;</span>] : !that.data.teams[num].mark <span class="hljs-comment">//关键在这里的实现</span>        &#125;)      &#125;    &#125;)  &#125;,&#125;)</code></pre><p>如上面代码所示：</p><p>在<code>this.setData(&#123;&#125;)</code>中可以使用<code>[str]</code>的形式指定要改变元素的地址</p><p>另外<code>&quot;变量名&quot;:data</code>则可以使用变量作为被改变元素地址</p><p><strong>参考资料:</strong></p><p><a href="https://blog.csdn.net/fxjzzyo/article/details/79263198">https://blog.csdn.net/fxjzzyo/article/details/79263198</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序-flex布局</title>
    <link href="/posts/49201/"/>
    <url>/posts/49201/</url>
    
    <content type="html"><![CDATA[<p>微信小程序布局主要有两种：</p><p>一是相对定位、绝对定位，繁琐麻烦，含兼容性不好</p><p>二是<code>flex</code>布局，这里有几篇简洁清晰的教程，记录一下</p><p><a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=00080e799303986b0086e605f5680a">https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=00080e799303986b0086e605f5680a</a></p><p><a href="https://www.jianshu.com/p/e4f371d6dc5e">https://www.jianshu.com/p/e4f371d6dc5e</a></p><p><a href="https://www.jianshu.com/p/f1c30c8bd3b3">https://www.jianshu.com/p/f1c30c8bd3b3</a></p><p><a href="https://www.jianshu.com/p/f82262002f8a">https://www.jianshu.com/p/f82262002f8a</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-字符串-列表-相互转换</title>
    <link href="/posts/34603/"/>
    <url>/posts/34603/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串（str）-gt-列表（list）"><a href="#字符串（str）-gt-列表（list）" class="headerlink" title="字符串（str）-&gt; 列表（list）"></a>字符串（str）-&gt; 列表（list）</h3><pre><code class="hljs python">str1 = <span class="hljs-string">&quot;a,b,ccc&quot;</span>list1 = str1.split(<span class="hljs-string">&quot;,&quot;</span>)  <span class="hljs-comment"># 括号里是分隔符</span>print(list1)</code></pre><p>输出：</p><pre><code class="hljs python">[a,b,ccc]</code></pre><h3 id="列表（list）-gt-字符串（str）"><a href="#列表（list）-gt-字符串（str）" class="headerlink" title="列表（list）-&gt;字符串（str）"></a>列表（list）-&gt;字符串（str）</h3><pre><code class="hljs python">str2 = <span class="hljs-string">&quot;.&quot;</span>.join(list1)  <span class="hljs-comment"># 引号里面为分隔符</span>print(str2)</code></pre><p>输出：</p><pre><code class="hljs python">a.b.ccc</code></pre><p><strong>参考资料:</strong></p><p><a href="https://blog.csdn.net/roytao2/article/details/53433373">https://blog.csdn.net/roytao2/article/details/53433373</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uwsgi-进程管理</title>
    <link href="/posts/44279/"/>
    <url>/posts/44279/</url>
    
    <content type="html"><![CDATA[<p>为了管理uwsgi进程的启动和运行，首先在配置文件中添加如下配置：</p><pre><code class="hljs ini"><span class="hljs-attr">stats</span>=%(chdir)/uwsgi/uwsgi.status<span class="hljs-attr">pidfile</span>=%(chdir)/uwsgi/uwsgi.pid</code></pre><p>使用：<code>uwsgi --iniuwsgin.ini</code>正常启动<code>uwsgi</code>进程</p><p>停止进程 <code>uwsgi --stop uwsgi/uwsgi.pid</code></p><p>重启进程：<code>uwsgi --reload uwsgi/uwsgi.pid</code></p><p>查看进程状态： <code>uwsgi --connect-and-readuwsgi/uwsgi.status</code></p><p><strong>参考资料:</strong></p><p><a href="https://blog.csdn.net/weixin_39584758/article/details/80356000">https://blog.csdn.net/weixin_39584758/article/details/80356000</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>uwsgi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序发送模版消息</title>
    <link href="/posts/1444/"/>
    <url>/posts/1444/</url>
    
    <content type="html"><![CDATA[<p>今天主要遇到两个问题，一个是小程序登陆态暂存与暂存时间管理的问题，另一个是小程序模版消息后端接口调用返回<code>47001 data format error</code>错误的问题。</p><h3 id="小程序登陆态暂存与暂存时间管理"><a href="#小程序登陆态暂存与暂存时间管理" class="headerlink" title="小程序登陆态暂存与暂存时间管理"></a>小程序登陆态暂存与暂存时间管理</h3><p>这部分直接贴腾讯官方文档 <a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=000a2c7c9f4a981b0086bd31e5b40a">https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=000a2c7c9f4a981b0086bd31e5b40a</a></p><h3 id="小程序模版消息后端接口调用返回47001-data-format-error错误"><a href="#小程序模版消息后端接口调用返回47001-data-format-error错误" class="headerlink" title="小程序模版消息后端接口调用返回47001 data format error错误"></a>小程序模版消息后端接口调用返回<code>47001 data format error</code>错误</h3><p>这部分问题是因为Django默认格式是<code>application/x-www-form-urlencoded</code>而小程序后台需要<code>json</code>格式才行</p><p>具体解决方法可能会因为请求发送方式的不同而改变，我这里是用的<code>requests</code>库</p><p><strong>解决</strong> </p><p>首先在请求头里面设置请求格式为<code>application/json</code>，然后使用<code>json</code>封装请求数据，具体实现如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> jsondata = &#123;    <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">123</span>,    <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">456</span>&#125;headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;response = requests.post(url=<span class="hljs-string">&#x27;url&#x27;</span>, headers=headers, data=json.dumps(data)) <span class="hljs-comment">#json.dump()封装</span></code></pre><p><strong>参考资料:</strong></p><p><a href="https://blog.csdn.net/weixin_41004350/article/details/78705415">https://blog.csdn.net/weixin_41004350/article/details/78705415</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/sendTemplateMessage.html">https://developers.weixin.qq.com/miniprogram/dev/api/sendTemplateMessage.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python添加ssl模块</title>
    <link href="/posts/5070/"/>
    <url>/posts/5070/</url>
    
    <content type="html"><![CDATA[<p>又遇到一个坑，Django需要<code>_ssl</code>模块，默认安装的Python没有，重新编译一下，教程很多，我简单记录一下。</p><p>进入Python的源码目录</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> Python-3.7.2/Modulesvim Setup.dist</code></pre><p>去掉下面几行前面的注释：<br><pre><code class="hljs vala"><span class="hljs-meta"># Socket module helper for SSL support; you must comment out the other</span><span class="hljs-meta"># socket line above, and possibly edit the SSL variable:</span><span class="hljs-meta">#SSL=/usr/local/ssl#_ssl _ssl.c \</span><span class="hljs-meta">#       -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \</span><span class="hljs-meta">#       -L$(SSL)/lib -lssl -lcrypto</span></code></pre></p><pre><code class="hljs bash">./configuremakesudo make install</code></pre><p>这样就完成了。</p><p><strong>参考资料：</strong></p><p><a href="https://www.cnblogs.com/stragon/p/5884205.html">https://www.cnblogs.com/stragon/p/5884205.html</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-程序的编译安装</title>
    <link href="/posts/25075/"/>
    <url>/posts/25075/</url>
    
    <content type="html"><![CDATA[<p>一直使用Mac习惯了homebrew的简单快捷，几乎从来没从源码编译安装过软件，这次服务器用的Ubuntu，其中有些用到的软件版本系统包管理没有提供，只能从源码编译安装，所以整理一下Linux编译安装软件的一些知识。</p><h3 id="编译安装一般步骤"><a href="#编译安装一般步骤" class="headerlink" title="编译安装一般步骤"></a>编译安装一般步骤</h3><p>步骤没啥可说的，一般就是下载源码<code>./configure</code> <code>make</code> <code>make install</code> 这几个步骤，中间出现问题解决就可以。下面主要探讨的是软件的默认安装目录以及，非标准目录安装的一些问题。</p><h3 id="非标准安装"><a href="#非标准安装" class="headerlink" title="非标准安装"></a>非标准安装</h3><p>一般情况下 <code>./cofigure</code>后面添加相应参数可以控制生成的Makefile文件，进而控制编译出来的版本，具体参数参照对应软件的文档即可。例如<code>--prefix</code>参数可以控制安装位置。</p><h3 id="这几步在做什么"><a href="#这几步在做什么" class="headerlink" title="这几步在做什么"></a>这几步在做什么</h3><p><code>./configure</code>是建立<code>Makefile</code> 文件</p><p><code>make</code>是编译</p><p><code>sudo make install</code>安装</p><h3 id="剩下的其他问题"><a href="#剩下的其他问题" class="headerlink" title="剩下的其他问题"></a>剩下的其他问题</h3><p>直接看这篇文章吧写的太好了，索性直接贴链接了</p><p><a href="https://www.jianshu.com/p/39101098ebbe">https://www.jianshu.com/p/39101098ebbe</a></p><p><a href="https://my.oschina.net/surjur/blog/349464">https://my.oschina.net/surjur/blog/349464</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu升级-sshd无法启动</title>
    <link href="/posts/35455/"/>
    <url>/posts/35455/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>ssh无法连接服务器，查看发现sshd没启动</p><p>尝试<code>sudo systemctl start sshd</code>启动报错:</p><pre><code class="hljs bash">Job <span class="hljs-keyword">for</span> ssh.service failed because the control process exited with error code. see systemctl status ssh.service and journalctl -xe <span class="hljs-keyword">for</span> details.</code></pre><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>首先<code>sudo /usr/sbin/sshd -T</code>检查配置发现<code>bad ssh2 cipher spec</code>错误</p><p>使用<code>ssh -Q cipher</code>看下目前使用的<code>ciphers</code></p><p>编辑<code>/etc/ssh/sshd_config</code>修改<code>Ciphers****</code>就OK</p><p>再次<code>sudo /usr/sbin/sshd -T</code>发现<code>bad ssh2 cipher spec</code><br>同理<code>ssh -Q mac</code>看下，然后改配置文件，再次<code>sudo /usr/sbin/sshd -T</code>发现正常了</p><p><code>sudo systemctl start sshd</code>启动成功，问题解决。</p><p>最后，吐槽一下腾讯后台没法复制粘贴，都是手输的。</p><p>参考资料：</p><p><a href="https://kingzcheung.com/archives/116.html">https://kingzcheung.com/archives/116.html</a></p><p><a href="https://forums.freebsd.org/threads/sshd-wont-start.51784/">https://forums.freebsd.org/threads/sshd-wont-start.51784/</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>django-uwsgi-部署</title>
    <link href="/posts/37675/"/>
    <url>/posts/37675/</url>
    
    <content type="html"><![CDATA[<p>今天在把Django部署到服务器的时候，本地跑得好好的东西，遇到了各种奇葩问题的轮番轰炸。</p><p>把我逼到抓狂，网上各种说法都有，各种奇葩解决方案，乱七八糟。终于搞定，特此记录一下。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>Ubuntu 16.01（没用最新是因为腾讯云最新就这个，一升级就炸，好吧是我自己太垃圾了）</p><p>Python3.7（从源码编译安装）</p><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><h3 id="问题1-ubuntu默认有python2-7和python3-5，没python3-7"><a href="#问题1-ubuntu默认有python2-7和python3-5，没python3-7" class="headerlink" title="问题1: ubuntu默认有python2.7和python3.5，没python3.7"></a>问题1: ubuntu默认有python2.7和python3.5，没python3.7</h3><p>apt install不星，最高3.5，习惯了homebrew一键搞定，还真挺懵逼，发现自己这个所谓的运维居然没从源码编译安装过东西，太傻逼了，一脸懵。</p><h4 id="解决1："><a href="#解决1：" class="headerlink" title="解决1："></a>解决1：</h4><p>没啥说的，编译安装就完了。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> wget https://www.python.org/downloads/release/python-370/</span><span class="hljs-meta">$</span><span class="bash"> tar -zxvf Python-3.7.0.tgz</span><span class="hljs-meta">#</span><span class="bash"> 把依赖库装一下子(并不知道为啥是这些，待思考)</span><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev liblzma-dev libffi-dev libc6-dev</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /path/to/downloaded/file/</span><span class="hljs-meta">$</span><span class="bash"> sudo ./configure</span><span class="hljs-meta">$</span><span class="bash"> sudo ./make</span><span class="hljs-meta">$</span><span class="bash"> sudo ./make install</span></code></pre><p>P.S. 如果还缺东西 那就缺啥补啥 少啥装啥</p><h3 id="问题2-ubuntu安装mysql"><a href="#问题2-ubuntu安装mysql" class="headerlink" title="问题2: ubuntu安装mysql"></a>问题2: ubuntu安装mysql</h3><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install mysql-server mysql-client  <span class="hljs-comment"># 让输密码就数一下 这是root的密码</span></span></code></pre><p>这步倒是没出啥问题，但是Django跑起来的时候会出现Error loading MySQLdb module: No module named ‘MySQLdb’</p><blockquote><p>因为Python3.5+并不支持MySQLdb，使用MySql可以使用pymysql代替，据说两者使用方式相同</p></blockquote><h4 id="解决2："><a href="#解决2：" class="headerlink" title="解决2："></a>解决2：</h4><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> pip install pymysql</span>...</code></pre><p>在<strong>init.py</strong>中添加</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysqlpymysql.install_as_MySQLdb()</code></pre><h3 id="问题3-配置uwsgi"><a href="#问题3-配置uwsgi" class="headerlink" title="问题3: 配置uwsgi"></a>问题3: 配置uwsgi</h3><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> pip3 install uwsgi</span>...</code></pre><p>nginx配置文件:</p><pre><code class="hljs nginx"><span class="hljs-comment"># mysite_nginx.conf</span><span class="hljs-comment"># the upstream component nginx needs to connect to</span><span class="hljs-attribute">upstream</span> django &#123;    <span class="hljs-comment"># server unix:///path/to/your/mysite/mysite.sock; # for a file socket</span>    <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8001</span>; <span class="hljs-comment"># for a web port socket (we&#x27;ll use this first)</span>&#125;<span class="hljs-comment"># configuration of the server</span><span class="hljs-section">server</span> &#123;    <span class="hljs-comment"># the port your site will be served on</span>    <span class="hljs-attribute">listen</span>      <span class="hljs-number">8000</span>;    <span class="hljs-comment"># the domain name it will serve for</span>    <span class="hljs-attribute">server_name</span> .example.com; <span class="hljs-comment"># substitute your machine&#x27;s IP address or FQDN</span>    <span class="hljs-attribute">charset</span>     utf-<span class="hljs-number">8</span>;    <span class="hljs-comment"># max upload size</span>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">75M</span>;   <span class="hljs-comment"># adjust to taste</span>    <span class="hljs-comment"># Django media</span>    <span class="hljs-attribute">location</span> /media  &#123;        <span class="hljs-attribute">alias</span> /path/to/your/mysite/media;  <span class="hljs-comment"># your Django project&#x27;s media files - amend as required</span>    &#125;    <span class="hljs-attribute">location</span> /static &#123;        <span class="hljs-attribute">alias</span> /path/to/your/mysite/static; <span class="hljs-comment"># your Django project&#x27;s static files - amend as required</span>    &#125;    <span class="hljs-comment"># Finally, send all non-media requests to the Django server.</span>    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">uwsgi_pass</span>  django;        <span class="hljs-attribute">include</span>     /path/to/your/mysite/uwsgi_params; <span class="hljs-comment"># the uwsgi_params file you installed</span>    &#125;&#125;</code></pre><p>uwsg配置文件:</p><pre><code class="hljs ini"><span class="hljs-comment"># mysite_uwsgi.ini file</span><span class="hljs-section">[uwsgi]</span><span class="hljs-comment"># Django-related settings</span><span class="hljs-comment"># the base directory (full path)</span><span class="hljs-attr">chdir</span>           = /path/to/your/project<span class="hljs-comment"># Django&#x27;s wsgi file</span><span class="hljs-attr">module</span>          = mysite.wsgi:application<span class="hljs-comment"># process-related settings</span><span class="hljs-comment"># master</span><span class="hljs-attr">master</span>          = <span class="hljs-literal">True</span><span class="hljs-attr">pidfile</span>=/tmp/project-master.pid<span class="hljs-comment"># maximum number of worker processes</span><span class="hljs-attr">processes</span>       = <span class="hljs-number">10</span><span class="hljs-comment"># the socket (use the full path to be safe</span><span class="hljs-attr">socket</span>          = /path/to/your/project/mysite.sock<span class="hljs-comment"># ... with appropriate permissions - may be needed</span><span class="hljs-comment"># chmod-socket    = 664</span><span class="hljs-attr">max-requests</span>=<span class="hljs-number">5000</span><span class="hljs-comment"># clear environment on exit</span><span class="hljs-attr">vacuum</span>          = <span class="hljs-literal">True</span><span class="hljs-attr">daemonize</span>=/var/log/uwsgi/yourproject.log</code></pre><p>应用配置文件</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> uwsgi --ini mysite_uwsgi.ini <span class="hljs-comment"># the --ini option is used to specify a file</span></span></code></pre><h3 id="问题4-Django-admin页面css等静态文件丢失"><a href="#问题4-Django-admin页面css等静态文件丢失" class="headerlink" title="问题4: Django admin页面css等静态文件丢失"></a>问题4: Django admin页面css等静态文件丢失</h3><p>这个其实文档里面写清楚了，没注意看。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>修改<code>seetings.py</code> 添加 <code>STATIC_ROOT = &quot;/var/www/example.com/static/&quot;</code></p><p>运行<code>python manage.py collectstatic</code>收集静态文件。</p><p>在linux配置文件中设置好地址，就OK。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/hzlnice/article/details/81140865">https://blog.csdn.net/hzlnice/article/details/81140865</a></p><p><a href="https://www.jianshu.com/p/3111290b87f4">https://www.jianshu.com/p/3111290b87f4</a></p><p><a href="https://www.jianshu.com/p/968403165b92">https://www.jianshu.com/p/968403165b92</a></p><p><a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html">https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html</a></p><p><a href="https://docs.djangoproject.com/zh-hans/2.1/ref/databases/#mysql-notes">https://docs.djangoproject.com/zh-hans/2.1/ref/databases/#mysql-notes</a></p><p><a href="https://docs.djangoproject.com/zh-hans/2.1/howto/deployment/wsgi/uwsgi/">https://docs.djangoproject.com/zh-hans/2.1/howto/deployment/wsgi/uwsgi/</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Nginx</tag>
      
      <tag>uwsgi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx+php-fpm</title>
    <link href="/posts/49243/"/>
    <url>/posts/49243/</url>
    
    <content type="html"><![CDATA[<h2 id="一、正向代理与反向代理"><a href="#一、正向代理与反向代理" class="headerlink" title="一、正向代理与反向代理"></a>一、正向代理与反向代理</h2><p>正向与反向是相对于人的感知来说的</p><p>可以感知 —-&gt; 正向</p><p>不可以感知 —-&gt; 反向</p><h2 id="二、php-fpm是啥？"><a href="#二、php-fpm是啥？" class="headerlink" title="二、php-fpm是啥？"></a>二、php-fpm是啥？</h2><p>php-fpm是 FastCGI 的实现，并提供了进程管理的功能。<br>进程包含 master 进程和 worker 进程两种进程。<br>master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。</p><h2 id="三、ngnix的配置"><a href="#三、ngnix的配置" class="headerlink" title="三、ngnix的配置"></a>三、ngnix的配置</h2><p>默认配置文件路径<code>/etc/ngnix/ngnix.conf</code></p><p>简单配置一下</p><pre><code class="hljs properties"><span class="hljs-attr">server&#123;</span>    <span class="hljs-attr">listen</span> <span class="hljs-string">80;</span>            <span class="hljs-attr">location</span> <span class="hljs-string">~ \.php$ &#123;  </span>            <span class="hljs-attr">root</span> <span class="hljs-string">html;  </span>        <span class="hljs-attr">fastcgi_pass</span> <span class="hljs-string">127.0.0.1:9000;  </span><span class="hljs-comment">        #fastcgi_index index.php;  </span>        <span class="hljs-attr">fastcgi_param</span> <span class="hljs-string">SCRIPT_FILENAME $document_root$fastcgi_script_name;  </span>        <span class="hljs-attr">include</span> <span class="hljs-string">fastcgi_params;  </span>        <span class="hljs-attr">&#125;</span><span class="hljs-attr">&#125;</span></code></pre><h2 id="四、php-fpm配置"><a href="#四、php-fpm配置" class="headerlink" title="四、php-fpm配置"></a>四、php-fpm配置</h2><p>配置文件路径<code>etc/php-fpm.conf</code></p><p>简单配置下<code>listen 127.0.0.1:9000</code></p><h2 id="五、数据传递过程"><a href="#五、数据传递过程" class="headerlink" title="五、数据传递过程"></a>五、数据传递过程</h2><blockquote><p> www.example.com<br>​        |<br>​        |<br>​      Nginx<br>​        |<br>​        |<br>路由到www.example.com/index.php<br>​        |<br>​        |<br>加载nginx的fast-cgi模块<br>​        |<br>​        |<br>fast-cgi监听127.0.0.1:9000地址<br>​        |<br>​        |<br>www.example.com/index.php请求到达127.0.0.1:9000<br>​        |<br>​        |<br>php-fpm 监听127.0.0.1:9000<br>​        |<br>​        |<br>php-fpm 接收到请求，启用worker进程处理请求<br>​        |<br>​        |<br>php-fpm 处理完请求，返回给nginx<br>​        |<br>​        |<br>nginx将结果通过http返回给浏览器<br>​        </p></blockquote><h2 id="六、一些小纠结"><a href="#六、一些小纠结" class="headerlink" title="六、一些小纠结"></a>六、一些小纠结</h2><p>1、首先，CGI是干嘛的？CGI是为了保证web server传递过来的数据是标准格式的，方便CGI程序的编写者。</p><blockquote><p>web server（比如说nginx）只是内容的分发者。比如，如果请求<code>/index.html</code>，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。好了，如果现在请求的是<code>/index.php</code>，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。Nginx会传哪些数据给PHP解析器呢？url要有吧，查询字符串也得有吧，POST数据也要有，HTTP header不能少吧，好的，CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。</p><p>当web server收到<code>/index.php</code>这个请求后，会启动对应的CGI程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。</p></blockquote><p>2、CGI是个协议，跟进程什么的没关系。那fastcgi又是什么呢？Fastcgi是用来提高CGI程序性能的。</p><blockquote><p>提高性能，那么CGI程序的性能问题在哪呢？”PHP解析器会解析php.ini文件，初始化执行环境”，就是这里了。标准的CGI对每个请求都会执行这些步骤（不闲累啊！启动进程很累的说！），所以处理每个时间的时间会比较长。这明显不合理嘛！那么Fastcgi是怎么做的呢？首先，Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。</p></blockquote><p>3、那PHP-FPM又是什么呢？是一个实现了Fastcgi的程序，被PHP官方收了。</p><blockquote><p>大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理（皇上，臣妾真的做不到啊！）所以就出现了一些能够调度php-cgi进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。好了PHP-FPM也是这么个东东，在长时间的发展后，逐渐得到了大家的认可（要知道，前几年大家可是抱怨PHP-FPM稳定性太差的），也越来越流行。</p></blockquote><p>Q: php-fpm是fastcgi进程的管理器，用来管理fastcgi进程的？？？</p><blockquote><p>对。php-fpm的管理对象是php-cgi。但不能说php-fpm是fastcgi进程的管理器，因为前面说了fastcgi是个协议，似乎没有这么个进程存在，就算存在php-fpm也管理不了他（至少目前是）。 有的说，php-fpm是php内核的一个补丁</p><p>以前是对的。因为最开始的时候php-fpm没有包含在PHP内核里面，要使用这个功能，需要找到与源码版本相同的php-fpm对内核打补丁，然后再编译。后来PHP内核集成了PHP-FPM之后就方便多了，使用<code>--enalbe-fpm</code>这个编译参数即可。</p></blockquote><p>Q: 修改了php.ini配置文件后，没办法平滑重启，所以就诞生了php-fpm？？？</p><blockquote><p>是的，修改php.ini之后，php-cgi进程的确是没办法平滑重启的。php-fpm对此的处理机制是新的worker用新的配置，已经存在的worker处理完手上的活就可以歇着了，通过这种机制来平滑过度。</p></blockquote><p>Q: 还有的说PHP-CGI是PHP自带的FastCGI管理器，那这样的话干吗又弄个php-fpm出？？？</p><blockquote><p>不对。php-cgi只是解释PHP脚本的程序而已。</p></blockquote><h2 id="在代理时如何保持请求头不变"><a href="#在代理时如何保持请求头不变" class="headerlink" title="在代理时如何保持请求头不变"></a>在代理时如何保持请求头不变</h2><blockquote><p>By default, NGINX redefines two header fields in proxied requests, “Host” and “Connection”, and eliminates the header fields whose values are empty strings. “Host” is set to the <code>$proxy_host</code> variable, and “Connection” is set to <code>close</code>.</p></blockquote><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /some/path/ &#123;    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;    <span class="hljs-attribute">proxy_pass</span> http://localhost:8000;&#125;</code></pre><p>参考资料：</p><p><a href="https://segmentfault.com/a/1190000007322358">https://segmentfault.com/a/1190000007322358</a></p><p><a href="https://segmentfault.com/q/1010000000256516">https://segmentfault.com/q/1010000000256516</a></p><p><a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/">https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/</a></p><p><a href="https://blog.csdn.net/sunyuhua_keyboard/article/details/78273700">https://blog.csdn.net/sunyuhua_keyboard/article/details/78273700</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github</title>
    <link href="/posts/11118/"/>
    <url>/posts/11118/</url>
    
    <content type="html"><![CDATA[<h2 id="Github-是什么？"><a href="#Github-是什么？" class="headerlink" title="Github 是什么？"></a>Github 是什么？</h2><blockquote><p>gitHub是一个面向<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/20720669">开源</a>及私有<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。</p><p>gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 <a href="https://baike.baidu.com/item/Ruby/11419">Ruby</a> on Rails、<a href="https://baike.baidu.com/item/jQuery/5385065">jQuery</a>、<a href="https://baike.baidu.com/item/python/407313">python</a> 等。</p></blockquote><p>简而言之，Github就是基于git的一个远程托管服务器。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>新建本地库</strong>：创建新文件夹，执行<code>git init</code></p><p><strong>克隆远程仓库</strong>：<code>git clone username@host:/path/to/repository</code></p><p><strong>添加与提交</strong>：</p><p>在进行文件更改后，准备提交时，你应该先把它们添加到缓存区，使用：<code>git add &lt;filename&gt;</code>或者<code>git add *</code><br>这是 git 基本工作流程的第一步；使用命令：<code>git commit -m &quot;代码提交信息&quot;</code>，可以提交实际改动。<br>完成以上两步后，你的改动已经提交到了 <strong>HEAD</strong>，但是还没到你的远端仓库。</p><p><strong>将代码提交到远程库</strong>：</p><p>你的改动现在已经在本地仓库的 <strong>HEAD</strong> 中了，通过执行<code>git push origin master</code>你就可以把代码提交到远程库了。</p><p>P.S. 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<code>git remote add origin &lt;server&gt;</code></p><p><strong>更新与合并</strong>：</p><p>更新你的本地仓库至最新改动: <code>git pull</code></p><p>在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。要合并其他分支到你的当前分支（例如 master）<code>git merge &lt;branch&gt;</code></p><p>git 会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 <em>冲突（conflicts）</em> 。 这时候就需要你修改这些文件来人肉合并这些 <em>冲突（conflicts）</em> 了。改完之后，你需要执行如下命令以将它们标记为合并成功：<code>git add &lt;filename&gt;</code><br>在合并改动之前，也可以使用如下命令查看：<code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p><strong>工作流</strong>：</p><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p><p><strong>分支</strong>：</p><p>在你创建仓库的时候，<em>master</em> 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p><strong>e.g.</strong>: 创建一个叫做“feature_x”的分支，并切换过去：<code>git checkout -b feature_x</code><br>切换回主分支：<code>git checkout master</code><br>再把新建的分支删掉：<code>git branch -d feature_x</code><br>除非你将分支推送到远端仓库，不然该分支就是 <em>不为他人所见的</em>：<code>git push origin &lt;branch&gt;</code></p><p><strong>分支操作</strong></p><p>查看分支<code>git branch</code><br>查看所有分支（本地和远程）<code>git branch -a</code></p><p>删除本地分支<code>git branch -d &lt;NAME&gt;</code></p><p>删除远程分支<code>git push origin -d &lt;NAME&gt;</code></p><p>或者<br><code>git branch -r -d origin/branch-name</code> 删除追踪<br><code>git push origin :&lt;NAME&gt;</code> 删除远程分支</p><p>清理本地无效分支(远程已删除本地没删除的分支) <code>git fetch -p</code></p><h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><p><strong>使用时光机</strong>：</p><p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：<code>git checkout -- &lt;filename&gt;</code><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p><p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：<br><code>git fetch origin</code>   <code>git reset --hard origin/master</code></p><p>撤销文件修改 <code>git ls-files -m | xargs git checkout --</code>(过时)</p><p>撤销文件删除<code>git ls-files -d | xargs git checkout --</code></p><p>删除所有没有托管给git的文件<code>git clean -d -xf</code></p><p><strong>查看提交历史</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># 每个提交在一行内显示</span>git log--oneline<span class="hljs-comment"># 在所有提交日志中搜索包含「homepage」的提交</span>git log--all --grep=<span class="hljs-string">&#x27;homepage&#x27;</span><span class="hljs-comment"># 获取某人的提交日志</span>git log--author=<span class="hljs-string">&quot;name&quot;</span></code></pre><p><strong>查看我的分支和master的不同</strong></p><p><code>git diff master..my-branch</code></p><p><strong>修改提交</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># 编辑上次提交</span>git commit --amend -m <span class="hljs-string">&quot;更好的提交日志&quot;</span><span class="hljs-comment"># 在上次提交中附加一些内容，保持提交日志不变git add . &amp;&amp; git commit --amend --no-edit</span><span class="hljs-comment"># 空提交 —— 可以用来重新触发 CI 构建</span>git commit --allow-empty -m <span class="hljs-string">&quot;chore: re-trigger build&quot;</span></code></pre><p><strong>参考资料：</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218984&amp;idx=2&amp;sn=72372ab5221959163584f185e2fd86ce&amp;chksm=befe21c98989a8df005a856670698690fc9c908e383660973485627195f2e28a884d6f7fa8d6&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1580365611047&amp;sharer_shareid=efe1d9f044d3c2058cad3eb75cb87cc6#rd">git 高级用法小抄</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello-world</title>
    <link href="/posts/9408/"/>
    <url>/posts/9408/</url>
    
    <content type="html"><![CDATA[<p>一直想要专心写一些东西，却迟迟没能付诸实践，之前尝试用Wordpress建站，写来写去把好好的技术分享站写成了生活琐事流水账，违背了初心不说，最后也没坚持下来。</p><p>这次室友开了个人公众号，准备写点东西，我也跟着他的脚步，决定重新开博，索性放弃了繁杂臃肿的Wordpress 改用Hexo，简洁清晰，专心写内容。</p><p>感谢室友的支持，也感谢目前所用的这个主题的作者，也希望在不久的将来自己也可以写一个漂亮的主题出来。</p><p>最后贴一下室友的公众号，ZEROHA0，欢迎关注，多多支持。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
